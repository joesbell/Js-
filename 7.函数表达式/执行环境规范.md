### 执行环境(执行上下文)

当进入可执行代码时，就会创建一个执行环境(执行上下文)。显然地，永远会有一个执行环境存在，那就是全局代码的全局执行环境。

执行环境由以下三个组件构成:

* **词法环境组件**: 一个 词法环境， 用于解析该执行上下文中的标识符。

* **变量环境组件**：一个 词法环境， 用于保存该执行上下文中 通过 var 和 function 创建的绑定。

* **this绑定组件**： 指定该执行上下文中 ，this关键字所关联的值。

在执行环境初始化时，其 词法环境组件 和 变量环境组件 是同一个值(**准确的说是同一个引用！！！**)。 但是在该执行环境执行的过程中， 变量环境组件(**指向的引用！！！**)是不会变化的， 而词法环境组件(**指向的引用！！！**)有可能改变。


#### 重点理解！

这里是容易理解错误的。 在 声明式绑定初始化.js中的理解可以说是建立在错误的基础上分析的。

变量环境组件和词法环境组件**指向的对象的内容都会时刻发生改变**，正如规范所说的，变量环境组件和词法环境组件在初始时是**同一个对象**。

只是，变量环境组件**侧重于说明 变量声明和函数声明**，而词法环境组件**侧重于说明整个执行环境的标识符**。

用第四章的话来说，**变量环境组件**实际上在说**执行环境的静态性**。而**词法环境组件**实际在说**执行环境的动态性**。

正如规范所说，执行环境词法环境组件是有可能变化的。该含义的准确解释是 词法环境组件**所指向的对象**是可以改变的。方式是通过某些statement语句对执行环境的词法环境组件进行改变，比如 with语句，比如 try语句，catch语句。

可以说，变量环境组件和词法环境组件是同一个对象是一种常态，只是一些特殊语句会**临时打破**这种常态罢了(然而最终依旧回归常态)。

### 标识符解析(标识符求值)(变量取值)

首先我们需要明白的一点是，标识符解析是在**代码执行期中**进行的，而不是在解析阶段。 标识符解析这个名称非常令人迷惑，让人误解为是在代码解析阶段进行的，其实， 标识符求值更贴切一点。

标识符的解析是指使用当前执行上下文的**词法环境组件**，通过标识符名name获取其对应的绑定引用规范类型值的过程。

其方式是通过调用 词法环境运算中的 GetIdentifierReference(词法环境组件,标识符名，是否是严格模式)获取引用规范类型的过程。这个过程同时也是经验上的 **变量沿着函数定义时的作用域链取值的过程**。

***

### 可执行代码类型

ECMAScript中具有三种可执行代码:
* 全局代码 ： 全局代码指的是 不包含 函数体的部分。

* 函数代码 :  函数代码指的是函数体内部的不包含嵌套的函数体的部分。

* eval代码 : eval代码指的是传入eval函数的字符串部分。 

因此，对应的就会有三种类型的执行环境。而每一种执行环境的创建都是不一样的。


***

#### 全局执行环境的建立

全局执行环境的 词法环境组件为 全局环境，变量环境组件为 全局环境， this绑定为 全局对象。

最后再使用全局代码 执行 声明式绑定初始化。

#### eval执行环境的建立

eval执行环境的建立首先需要确定的是eval代码的调用方式是 直接调用还是间接调用，具体参看 eval的直接调用和间接调用.md 。

如果没有调用环境或者是并非直接调用eval函数执行eval代码，那么，其:
* 词法环境组件为 全局环境
* 变量环境组件为 全局环境
* this绑定为 全局对象。

不管是否是在严格模式下均是如此.

如果eval代码具有调用环境或者是通过直接调用eval函数来执行的，那么，其:
* 词法环境组件为 当前执行环境下的词法环境组件
* 变量环境组件为 当前执行环境下的变量环境组件
* this绑定 为 当前执行环境下的 this绑定。

如果直接调用eval代码在严格模式下，那么，其:
* 词法环境组件为 以外部词法环境调用NewDeclarativeEnvironment创建的新的声明式词法环境
* 变量环境组件为 以外部词法环境调用NewDeclarativeEnvironment创建的新的声明式词法环境。
* this绑定 为 当前执行环境下的 this绑定。

##### 严格模式下的eval代码

**在直接调用eval时**:
如果eval代码是在严格模式下(本身是严格模式代码或者当前执行环境为严格模式的)的，那么 会**以当前执行环境的词法环境lex为参数调用 NewDeclarativeEnvironment(lex) 创建一个新的声明式词法环境**。
并以该新的声明式词法环境作为 变量环境组件和 词法环境组件。
也就是说，**严格模式下的eval代码是不会对外部的词法环境和变量环境产生影响**的一一这里的影响是指**使得外部词法环境组件新增或者删除标识符绑定**，但是是**可以改变外部词法环境中的标识符绑定的值**的。
更为细致的解释参看 严格模式下的eval执行环境.js 。

**在间接调用eval时**:
需要明白的是，无论**外部代码段是否为严格模式**均使用全局环境作为eval的词法环境组件和变量环境组件，而this绑定组件为全局对象.分析时只需要根据词法环境进行分析即可。

但是**间接调用eval函数代码段中是否为严格模式执行只取决于 eval代码段是否以"use strict"开头，而不受外部是否为严格模式执行的影响**，这一点是与直接调用eval函数不同的地方。

示例代码如下:

    "use strict";
    try{
        m=10;
    }catch(e){
        console.log("严格模式下声明变量必须加上var，否则抛出异常:",e.message);
    }
    window.eval("m='但是通过eval间接调用，却可以不用var来声明变量，这是因为间接调用eval函数，eval代码段默认都是非严格模式执行，除非代码段以 use strict 开头，因此这里本质是非严格模式的eval代码段'"); //修正间接调用eval代码的严格模式的错误解释
    console.log(m); //非严格模式下当然可以直接在全局对象上声明属性

***
最后在使用eval内的代码执行 声明式绑定初始化。

以上内容具体参看 eval严格模式和是否直接调用对执行环境的影响.js

#### 函数执行环境的建立

执行一个函数时，势必有调用者，参数，以及函数对象。

函数执行环境的 词法环境组件 和 变量环境组件都是 **以函数对象的 \[\[Scope]]规范属性为参数lex 调用NewDeclarativeEnvironment(lex)返回的新的声明式词法环境**。

而函数的this绑定都是由调用者提供的this来决定的:
* 如果this为undefined或者null，那么this绑定为全局对象。
* 否则，如果this不是Object类型数据(number boolean string)，那么就将其转换为其包装类型对象作为this绑定。
* 否则，如果this是个Object类型数据，那么就直接使用this作为this绑定。
* 特殊的，在严格模式下，this绑定就是调用者提供的this.

最后，再使用 函数对象的\[\[Code]]规范属性的内容(即函数体内的代码段)和参数进行 声明式绑定初始化。

***
### 声明式绑定初始化 (执行环境的静态初始化)

声明式绑定初始化其实是在做一件事，**在代码真正执行之前，将 变量声明，函数声明，函数调用参数 以绑定的形式添加到 变量环境组件的 环境记录中**。
是**静态的解析变量声明 函数声明 形参赋值的行为**。

使用 对象式环境记录 还是 声明式环境记录 来作为 变量环境组件 的环境记录是取决于ECMAScript脚本的类型。

下面开始进行 声明式绑定初始化过程：

1. 首先进行一些前置的工作: 如果代码是eval代码，设置configurableBindings为true，否则为false。 如果是严格模式，则令strict为true，否则为false。同时将该变量环境的记录项设置为env。 

2. 对**传入的参数进行解析**:**传入的参数列表args**的长度为**argsCount**，函数的\[\[FormalParameters]](形参列表)的值为**names**。
*  从0开始遍历names。索引为index
*  index如果大于argsCount,那么将value赋值为undefined，否则value为args\[index]。 (**实际传参数量小于函数实际形参数量时，那么没有传入的参数的值会被当做undefined**)
*  调用 env的 HasBinding( names\[index]),如果返回false,那么调用CreateMutableBinding(names\[index])创建该形参的绑定。 (**这也是为什么同名参数时，后面传入的参数值会覆盖前面传入的参数值**)
*  最后再调用 SetMutableBinding(names\[index],value,strict)将传入的具体的参数值同标识符绑定起来。

3. 对**代码中的函数声明进行解析**:按照源码顺序，遍历整个执行环境内的代码。
* 令 fn为每一个function函数声明的标识符。
* 调用env.HasBinding(fn),此时需要根据环境是否具有该标识符绑定做出抉择。
    * 如果返回false，说明环境中没有该标识符的绑定，那么调用 CreateMutableBindings(fn, configurableBindings).  (**这里也说明了，eval代码中的函数声明的标识符是可以被delete删除的。**)
    * 如果返回true，说明环境中已经有该标识符的绑定了,此时需要根据 变量环境 是否为 全局环境的环境记录做出抉择。其根本目的是为了**防止修改全局对象上的 不可配置 || 数据属性|| (不可写 && 不可遍历)的属性（全局环境中的环境绑定对象就是全局对象global本身，环境中的标识符就是该绑定对象的属性）**。
* 如果env是全局环境的环境记录，那么currentDesc为global调用\[\[GetProperty]]内部方法的结果，该方法返回该名称的属性的属性描述符。(**这里的本质其实是在说明，global环境中的标识符是看做global的属性的。因此重新声明就必须得该属性可配置或可写**)
    * 如果该属性描述符currentDesc的configurable属性为true，那么会用{value:undefined,enumerable:true,configurable:configurableBinds,writable:true}覆盖currentDesc(global.\[\[DefineOwnProperty]])。
    * 如果该属性描述符currentDeSC的configurable属性为false.如果是一个访问器类型的属性，或者其 enumerable=false writable=false ,(**可以认为这是\[\[CanPut]]规范属性返回false的结果**),那么会抛出异常。
* 最后如果以上没抛出异常，则调用 env.SetMutableBinding(fn,f函数对象,strict)。**进行函数声明覆盖**

4. 对 **"arguments"** 这个标识符进行绑定：调用env.hasBinding("arguments")方法判断是否当前环境记录项中已经包含 arguments这个标识符绑定。
* 如果当前环境记录项中已经包含这个标识符绑定，那么在当前环境记录项中就没有Arguments对象的引用了。 **实际上就是说，函数的形参和函数体内部的函数声明可以为arguments，此时就会让函数的Arguments对象无法绑定到标识符arguments上**
* 如果当前环境记录项中没有包含arguments这个标识符绑定，那么根据是否是strict模式，进行以下判断。
    * 如果strict为true，则以 arguments为参数调用 env的CreateImmutableBinding方法创建一个不可变的标识符绑定并使用env.InitializeImmutableBinding（"arguments",args）初始化Arguments对象。
    * 如果strict为false,则以 arguments为参数调用 env的CreateMutableBinding方法创建一个可变的标识符绑定并使用env.SetMutableBinding("arguments",args,false)设置arguments绑定的值,该标识符绑定不可删除。
    * 需要注意的是，无论是否是严格模式，**Arguments这个ArrayLike对象都是可以修改自身属性的**。区别在于，严格模式下不能修改arguments标识符绑定的指向，而非严格模式可以。同时需要明白的是，**arguments标识符是不能被delete操作符删除**的。
    (之前eval代码段中可以删除函数声明，但是变量和函数声明是有区别的，变量默认都是不能进行删除的。) 
    
5. 对 **代码中的变量声明进行解析**:按照源码顺序，遍历整个执行环境内的代码。
* 调用当前环境记录env.hasBinding()方法,判断当前环境中是否含有该标识符绑定。
    * 如果返回false,那么表示没有该绑定.那么就以标识符名和configurableBinding为参数，调用env.CreateMutableBinding(标识符名,configurableBinding)创建一个新的可变的环标识符绑定,并使用env.SetMutableBinding(标识符名,undefined,strict)设置初始值为undefined.
    (**eval代码段中声明的变量可以被删除正是因为eval代码中声明变量时configurableBinding为true**)
    
以上，就是整个声明式绑定初始化过程。 关于Arguments对象的创建，留待以后需要分析时再根据规范分析。


***

### With语句规范解析

With语句的本质是给 语句内部的执行环境的词法环境链上(有一种作用域链的感觉)添加一个**对象环境记录项**。 然后使用这个增强后的词法环境执行with语句内部的代码，最后，再**恢复到原本的词法环境**。

对于 

    with(expression){
        statement...;
    }
 
规范的执行过程如下:

* 令val为解析执行expression的结果，令obj为 规范方法ToObject(GetValue(val))的结果
* 令oldEnv为当前执行环境的词法环境组件。调用newObjectEnvironment(obj,oldEnv)创建一个新的词法环境newEnv，newEnv的外部词法环境引用为oldEnv,其对象式环境记录项的绑定对象为obj。 **(这里的作用就相当于将绑定对象放置于作用域链顶端)**
* 设置newEnv词法环境的provideThis标志为true。 **当provideThis为true时，环境记录项的ImplicitThisValue()方法返回的对象为绑定对象。需要注意的是，这里表示的并不是this取值，而是变量的取值的默认对象**
* 设置运行中的执行环境的词法环境组件为newEnv。
* 令解释运行statement代码的结果为returnValue。
* 设置运行中的执行环境的词法环境组件为oldEnv。
* 返回returnValue。
 
这里需要注意的一点是，看似词法环境还原成最初的了，就以为词法环境的内容是不变的。 其实是错误的。 **不变的**只是**词法环境所指向的对象**。 但是**该对象的属性内容是会发生改变**的！！！
切记！这是极其容易犯错的。 在 with语句的影响.js 中的分析就犯错了。

再在这里说说with语句的作用。

通过**临时**将当前执行环境的词法环境组件替换为一个新的以某个对象为绑定对象的对象式词法环境，这样在with语句的代码段执行过程中，使用的词法环境就会发生改变。
此时进行标识符解析，就会首先在该新的对象式词法环境中寻找标识符，以此达到**通常所说的将某个对象放到作用域链顶端的位置的作用**。

但是这会带来一个问题：
* 函数声明的\[\[Scope]]是根据**变量环境组件**来的。
* 函数表达式的\[\[Scope]]是根据**词法环境组件**来的。
* 在with语句中产生的函数声明和函数表达式，由于词法环境组件和变量环境组件的指向是不同的，因此**其\[\[Scope]]是不同的**
* 导致函数在执行时依据\[\[Scope]]生成的声明式词法环境是不同的。而这个声明式词法环境是作为函数执行环境的变量环境组件和词法环境组件的。
* 导致函数在进行标识符解析时，可能会沿着不同的路线寻找标识符。即函数声明是**沿着变量环境组件**寻找，而函数表达式是**沿着词法环境组件**寻找。

这也就是 with语句的影响.js 想说明的内容一一由于with语句会使**变量环境组件和词法环境组件临时地不为同一个对象**，因此在规范上**导致函数声明的函数对象和函数表达式的函数对象中的标识符解析路线不同**。

但是在实际的JS实现中，在这种情况下的标识符解析的路线是相同的，这就是和规范的不一致。


##### provideThis 和 ImplicitThisValue

我们再来说说这个 provideThis标志位，以及 词法环境记录项的ImplicitThisValue函数.

规范中说：ImplicitThisValue函数返回的是 当从该环境记录项的绑定中获取一个函数对象并且调用时，该方法返回该函数对象使用的 this 对象的值。 我们需要注意的是，这个说法是非常容易让人混淆的。
甚至可以说，这个说法是错误的。

我们先说说在OOP中 **.** 代表什么，一般而言用于OOP使用的消息传递模型，obj.method / obj.prop ,本质上代表着 我们向obj 传递 一个消息，这个消息的类型是 method或者prop,对象则是obj。

可以明确的是，消息的主体对象obj是必须存在的。但是某些时候我们为了方便省略obj时，消息的主题obj又从哪里获取呢？ 一一 这就是 **隐式this**，更准确的说是 **隐式对象**。(有种词法环境解析标识符的感觉)

而ImplicitThisValue函数返回的正是 这个 隐式this， 区别于我们平常所说的 this 一一那是**显式this**。

因此，最准确的说法，ImplicitThisValue函数返回的是 从该环境记录项的绑定中**获取一个消息类型的标识符**（这个标识符所代表的可以是属性，也可以是方法）时，**默认的消息主体对象的取值**。

而 ImplicitThisValue函数默认都是返回undefined的，除非是在 对象式环境记录项中，**通过设置 provideThis为true，使其返回的隐式this为 环境记录项的绑定对象**。

其造成的结果就是，比如在浏览器中，我们访问全局属性无需使用 global.prop访问，而可以直接使用 prop访问，因为全局环境就是一个对象式环境记录项，其绑定对象为global对象。

同理，当我们在with语句中访问到的所有 标识符， 都会**被首先当做 某个隐式对象的属性或者方法**。

由此，隐式this是 对象式词法环境记录项中 实现 **对象属性  到 变量标识符** 的一种解释。
另一种解释就是依靠解析标识符：解析标识符的原理是沿着词法环境寻找标识符绑定一一而with语句恰好就创建了一个新的对象式词法环境，并将其放在了词法环境链的最前端，其外部引用指向原本词法环境组件。

比较特殊的一点，在ECMAScript中， **. 是具有特殊性**的。 往往在其他语言中  obj.prop/method 这种传递是必须要求 prop/method 必须存在。 但是在EMCAScript中，这种传递并不依赖于prop/method存在，不存在则为undefined。

由此导致了在解析标识符时,对于 "a.b.c"这种标识符，ECMAScript在词法环境中寻找的标识符绑定其实只有"a"一一也就是**仅仅解析的是 "a"这个标识符，而不是完整地解析"a.b.c"**。详细可以参见with语句的影响3.js中的错误理解。

实际来看，这种隐式this的解释是没有词法环境标识符解析好的。 参看with语句的影响4.js
***

### Catch语句规范解析

Catch语句的本质是给 语句内部的执行环境的词法环境链中新增一个**声明式环境记录项**。然后使用这个声明式环境记录项作为词法环境来执行catch语句中的代码，执行完毕后，在**恢复到原本的词法环境**。

而且Catch语句是必须紧挨着try语句使用的。对于

    try{
        statement...
    }catch( identifier ){ //可以看到，这里是一个 identifier标识符，catch语句真实表达的含义是对于 try语句抛出的异常进行异常处理，try语句会将该异常对象传入，而catch语句就通过idetifier这个参数来接受该异常对象。
        statement...
    }
    
其规范的执行过程如下:
令 errorObj 为 try语句抛出的异常。oldEnv为当前执行环境的词法环境组件以及变量环境组件。
* 调用 newDeclarativeEnvironment(oldEnv)创建一个新的以oldEnv为外部词法环境引用的 声明式词法环境。该声明式词法环境的环境记录项中初始不包含任何标识符绑定。
* 调用 newEnv.createMutableBinding(identifierName) 创建一个 identifier可变标识符绑定。
* 调用 newEnv.setMutableBinding(identifier, errObj, false) 绑定 异常对象到该可变标识符上。 需要注意的是，这里默认是使用的非严格模式，因为这是无关紧要的。
* 设置执行环境的词法环境为newEnv。
* 执行代码，并令 returnObj为执行代码返回的结果。
* 设置执行环境的词法环境为oldEnv。
* 返回 returnObj。

catch语句往往不会对内部代码的执行造成结果上的副作用，这一点不同于with.原因可以看下面的对比。 实际上还是有影响的。

***

### 对比with和catch

究其本质： 
* with语句的信息量更大, with产生的对象式词法环境会使 with语句执行时的词法环境中 凭白多出 **绑定对象包含的所有属性**,这些属性会被当做变量来看待。而catch语句产生的声明式词法环境，**只会天生地附带一个标识符绑定**。 
* with语句和catch语句对执行环境产生的**副作用是一致的**:使执行环境的变量环境组件和词法环境组件不一致。

换句话说
    
    var obj={a:"a",b:"b"};
    with(obj){
        ...  
    } 
    /*
    *带来的影响是在with语句内部的词法环境中多出了obj所有的属性
    * a -> "a"
    * b -> "b"
    */
    
    try{
        throw obj;
    }catch(identifier){
        ...
    }
    /*
    *带来的影响是在catch语句内部的词法环境中多出了一个标识符：
    * identifier -> obj
    */
    
如果用 对象式词法环境记录项来类比地看待catch语句， 那么catch语句实际上绑定对象是 { identifier: obj },因此catch语句不会给人一种在变量的解析链上obj对象被推入顶端的感觉(**只影响到了identifier的解析**)，
而 with语句的绑定对象实际是 { obj的每个属性名 : obj的每个属性值 }，就会有这种感觉(**影响到了绑定对象的所有同名属性的标识符解析**)。
    
