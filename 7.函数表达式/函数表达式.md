# 函数表达式

之前我们就说过，定义一个函数的方式有两种：
* 函数声明 (享受函数声明提升)
* 函数表达式赋值

而函数一般都有一个非标准的属性name,其值代表自身名字的字符串。

而所谓的匿名函数，就是没有名字的函数，其name属性为空字符串。

***

### 递归

递归往往是函数内部通过名字调用自身。但是我们为了保证函数名和函数本身没有耦合，应该使用两种方式来完成递归。
* 使用arguments.callee

* 使用命名函数表达式

我们之前讲过匿名函数表达式:

    var method=function(){

    }; //这就是一个匿名函数表达式. 其name属性为空字符串. 这里是将这个匿名函数赋值给method变量

而命名函数表达式 和函数声明非常像:

    var method=function f(){

    };//这就是一个命名函数表达式. 其name属性为 "f" . 这里是将这个命名函数表达式赋值给method变量

唯一的区别，此时的函数表达式是作为值被赋给了一个变量。 如果没有赋值操作，那么以function开头的命名函数表达式就是一个函数声明。

在递归中，arguments.callee来解除函数名耦合的方案在严格模式下是行不通的，此时只能使用命名函数表达式。

对于命名函数表达式，我们要记住一点，其**命名的作用域只在函数表达式内部**，因此不会干预外部的同名属性。

***

### 闭包

首先我们需要给闭包下个定义： 在函数中使用**别的作用域的变量**，那么该函数就是一个闭包。

在函数调用的时候，会生成该函数的执行上下文和作用域链。

每一个执行上下文中，都具有一个表示该环境变量的**变量对象**,全局变量的变量对象一直都存在,而普通函数的变量对象，只在调用时创建并存在。

在内部的**\[\[Scope]]**属性中保存着当前环境的作用域链，而函数的作用域链保存在函数的**\[\[Scope]]**属性中。

在**调用函数**时，作用域链的构建是通过将 函数内部的\[\[Scope]]属性复制一份，并将函数的本地活动对象推入作用域链的前端完成的。

而在另一个函数中**创建的函数**则会将外部函数的活动对象添加到其作用域中，因此，会额外占用一定的内存。

**静态性**地占用更多内存：

我们可以这样理解：闭包函数为了能访问外部的自由变量，必须通过将其活动对象添加到作用域中，才能在变量访问时能够通过查找作用域链的方式
访问到该自由变量。 因此，在全局中创建的函数和在函数中创建的函数(不会该闭包函数最终是否被外部函数返回)相比，天然地，全局中创建的函数更加节省内存空间，
因为全局中创建的函数，其作用域链上只有全局变量对象和本身的活动对象，而函数中创建的函数，其作用域链还要包含一个外部函数的活动对象。 就算整个执行过程中，闭包函数并
没有被返回，而是直接在外部函数中调用，那么相比于在全局中创建的函数，其内存占用也更大。
这就是闭包占用更大内存空间的本质，由其本身决定的:**为了访问外部作用域的变量而不得不将外部作用域的活动对象保存在其执行上下文的作用链中。**

**动态性**地占用更多内存:

闭包占用更多内存的另一点在于：一般的函数，执行完毕后，其局部活动对象就会被销毁，内存就会被回收。
而当一个函数返回一个闭包函数的时候，虽然外部函数是执行完了，但是其活动对象是不能被销毁的，因为在更外部引用着闭包函数，而闭包函数的作用域链中又包含了外部函数的活动对象，
由此因为这种**使用方式**就造成了：**虽然外部函数执行完毕，但是外部函数的活动对象无法被销毁的情况**，因此往往闭包更耗内存。


***
这里我们再提提变量对象

### 变量对象

变量对象是跟执行上下文非常相关的一个东西。我们可以说变量对象是一种特殊的机制，用于告诉解释器，执行上下文中的用到的数据存储在哪里以及如何访问这些数据。

在执行上下文理解的时候，我们曾说过执行上下文分为多种，但是对于每一种执行上下文，其初始化操作都是类似的。当时所说的执行上下文的初始化过程，其实就是
在执行上下文中生成变量对象的过程。

变量对象是依附于执行上下文而存在的一个特殊的抽象对象，存储着执行上下文中的以下内容:
* **通过var**声明的变量(也即变量声明)
* **通过function声明**的函数(也即函数声明)
* 函数的参数，也就是传入的 arguments对象(因为只有函数有执行上下文，而函数肯定有参数传入)

一般而言我们是不能直接访问这些变量对象的，因为这些变量对象是内部机制的一种实现。
特殊地，**全局上下文中的变量对象一一即全局变量对象 是 全局对象global本身**。 也就是说Global对象既是全局对象又是全局变量对象。
而在浏览器中，Global对象又是window对象实现的一部分，我们虽然不能直接访问global对象，但是我们可以间接通过window对象来访问
global对象，以此达到访问全局变量对象的目的。

与变量对象相关的一个概念是活动对象。 
所谓活动对象，其实是指 函数的变量对象。 

之所以是活动的，是因为函数的变量对象并不是一直处于激活状态：当我们调用一个函数时，其变量对象激活了，因此就叫做活动对象。当我们使用完一个函数后，这个变量对象就处于休眠状态。
这是不同于全局变量对象的，全局变量对象的生命周期是整个代码的执行周期。因此可以说全局变量对象是时刻处于激活状态的活动的变量对象。

我们在浏览器中说过，global全局变量对象是window实现的一部分。但是其实这也**不是最准确**的说法。

**PS：重点来了**。
#### 全局的变量对象(VO variable object )

所谓**全局变量对象(全局对象)，是在执行代码之前就创建好了的对象**。这个global对象初始化就携带了一些属性：比如Math,String,Date等等**单体内置对象**。
因此，真实的情况是， 全局对象global至高无上。 window只是在浏览器中global对象的一个属性罢了。 只是**window属性很特殊一一global对象的window属性是指向global对象自身的**。

    global={
        //一些初始化的内置对象
        Math: ...,
        String:...,
        Date:...,
        parseInt:function ....
        
        ...
        
        window:global
    }
    
这才是 window和global之间的真实关系。window是作为global对象的一个属性而存在的，而window之所以能表现出global的功能，只是因为window指向的是global。

因此，下面的代码就很好解释了:

    this===window ; //true  因为 this是global 而我们访问window只是省略了前面的全局对象global，真实的是在访问 global.window,而global.window就是指向global
    
    var a = 10; // 这个变量a 其实是存在 global中的 等同于 global.a=10
    this.a === 10; //true  。 this指向的是global。 最终指向的是global.a
    window.a === 10; //true  。 省略了global。 等同于 global.window.a 而global.window指向 global自身。最终指向的就是 global.a
    this.window.a === 10; //true 最能说明这层关系。 这里 this是global 。 因此是 global.window.a 同上。


#### 函数的活动对象(AO action object)
前面我们只是通俗的说了一下，为什么在函数中不叫变量对象 而叫活动对象。

其实这只是一回事。正如我们最开始所说的，变量对象只是一种机制，而不是具体实现。我们也可以称呼活动对象是变量对象，因为本质是相同的：都是**为代码中的变量名以及其所代表的数据提供访问信息和存储信息**。

函数在执行时，会创建函数的执行上下文，而在这个函数的执行上下文创建时， 函数的活动对象也就被创建(激活)了。
与全局变量对象不同的是，函数中，变量数据并不只是自身的，还有外部带来的，也就是参数。因此，**函数的活动对象中比普通的变量对象多了一个东西:Arguments对象**。

从这个意义(狭义)上来说，ECMAScript中只有一个变量对象：全局变量对象。 其余的都是(函数的)活动对象。
在这个层次，我们也可以这样界定，变量对象是一种在整个代码执行周期中存储变量信息的机制，活动对象是一种在函数执行周期中存储变量信息的机制。当然再更高的层次，
我们也可以统称 变量对象和活动对象都是一种存储变量信息的机制。

函数的AO带来了额外的Arguments对象(注意是大写的，而不是arguments属性)，而Arguments对象又带有以下属性:
* callee 拥有这个Arguments的AO的所有者函数对象。
* length 真实传入的参数个数
* arguments\[index] 索引传入的第index个参数

当函数的AO不存在时(函数没被执行，AO没被激活)，函数对象的arguments属性是null值。
而当函数AO激活时，函数对象的arguments属性是 Arguments对象。Arguments对象是一个伪数组对象。

函数对象的arguments属性是一个不可重定义不可重写的的属性，但是，这不意味着所指向Arguments对象永远是同一个对象。
**在底层，arguments属性指向的Arguments对象是在一直变更的**。这看似是矛盾的，实则不是矛盾的一一因为属性的特性用于限制用户的行为的，而并不会限制底层。

参考ES5规范中 Arguments对象创建：
Arguments 对象通过调用抽象方法 CreateArgumentsObject 创建，调用时将以下参数传入：func、names、args、env、strict。
* 将要执行的函数对象作为 func 参数
* 将该函数的所有形参名加入一个列表，称为 names 参数
* 将所有传给内部方法 \[\[Call]] 的实际参数，称为 args 参数
* 将该函数代码的变量环境称为 env 参数
* 将该函数代码是否为严格代码作为 strict 参数

我们只需要明白以下代码的行为即可:

    function foo(x,y,z){
    }
    
    var temp=foo.arguments; //此时temp等于null
    
    foo(1,2); //此时temp依旧等于null ,但是 foo.arguments在此时被重新指向为 一个新建的 Arguments对象。
    

当然，还有一层原因，Arguments对象的生命周期应该和其依赖的 函数活动对象的 生命周期一致才对。 
当函数执行完毕后，活动对象销毁，Arguments对象是活动对象的一部分，因此被销毁也是正常的。 
于是，伴随着函数一次次的调用， Arguments对象被一次次地新建和销毁，就如同函数的活动对象被一次次激活和销毁一样。

#### AO和VO的演化过程

之前曾经说过，执行上下文是动静结合的。我们这里再提炼一下。

执行上下文的VO或者AO的静态性:
* 对于VAR变量声明，初始化赋值为undefined
* 对于function函数声明，初始化赋值为该函数对象

特别的，对于AO函数活动对象
* 函数的形式参数初始化赋值为实际传入的参数，如果没传入参数，那么赋值为undefined

执行上下文的VO或者AO的动态性:
* 伴随着代码的执行，AO和VO中变量所代表的值在不断更新。

当然，我们还要明确一点，VO或者AO的 **静态 初始化**赋值的 三种 类型的变量是具有优先级的：
* AO的函数的形参优先级最高。
* function函数声明优先级其次，但是会覆盖 函数形参。
* var变量声明优先级最低，不会覆盖前两者。

也就是说:

    function foo(x){
        console.log(x); //function x
        var x=10;
        function x(){
            ...
        }
    }
    
    对于这段代码的AO来说， 首先初始化时， 会将 变量 x 作为函数的参数进行初始化，如果实际调用时
    传入了参数就是该参数的值，否则就是undefined。
    但是由于又有函数声明，于是 变量 x 会被函数声明所覆盖。
    

这里再附带提一提变量声明。

#### var 变量声明

在ECMAScript中，只有var语句能够声明变量。 而不使用var声明的全局变量，实际上该全局变量并不是真正的变量，而**仅仅是全局对象的属性**。

真正的变量都具有无法通过delete操作符删除的性质(eval代码段中声明的除外，因为其configurableBinding为true，参看执行环境规范)。而对象的属性往往都是可以配置的。

因此:

    var a=10; //这是真正的变量。
    delete a; //返回false
    b=10; //这是在全局对象上添加一个属性。效果看似和全局变量相同，但是并不是全局变量。
    delete b; //返回true

***

以上最好结合 执行环境规范 查看。

***


### this

这里从ECMAScript规范来讲述this。

为了更好的说明this问题，我们得先理解 引用规范类型。

***

在这里总结一下this取值的所有情况:

* 普通的函数调用: 如果有对象作为调用者，那么this取值为该对象，否则，在严格模式下，this取值为undefined，非严格模式下，this取值为全局对象
* 构造函数调用： new 构造函数的方式调用时，this取值为**新创建的那个对象**。
* 原型链上的函数调用: 某个对象调用原型链上的函数，那么this取值为**实际调用函数的该对象**。
* call,apply,bind等特殊方法下的函数调用: this取值为指定的this对象。
* 箭头函数的调用：this取值为**创建该箭头函数时**，外部所提供的this取值。
* 普通DOM监听事件处理函数调用； this取值为**该事件所绑定的DOM对象**。
* with语句下的普通函数(该函数是绑定对象的属性)：this取值为**with语句的绑定对象**。
* HTML内联事件处理函数：HTML页面**函数调用参数中this取值为DOM对象**，函数体中的this取值为在非严格模式下为全局对象，严格模式下为undefined。
* 定时器回调函数：回调函数中this永远指向全局对象，无论是不是严格模式。

具体参看 各种函数调用的this取值分析 目录下的内容。

另外，对于一些特别的调用方式，可能会改变this取值，比如：

>> (1,foo)()   (0||foo)() 等类似的调用

实际上根据函数调用规范以及引用规范类型来看，左边的CallExpression解释执行以后已经不是一个引用规范类型了，而是一个已经GetValue(Reference)后的值了。

因此this取值为undefined。此时如果是严格模式，在函数调用时，this取值就是undefined，如果为非严格模式，this取值就会被替换为全局对象。

当然,bind函数绑定this取值后的函数的this取值是永远不会发生任何改变的，所以无视这个这条。

***

### 模仿块级作用域

在ECMAScript中是没有块级作用域的，因为可执行代码只有三种:
* 全局代码
* 函数代码
* eval代码

因此实际上就作用域而言，只有三种作用域：
* 全局作用域
* 函数作用域
* **严格模式eval代码**的eval作用域

因此，想要在ECMAScript中模仿块级作用域，实际上就是利用 立即执行函数的函数作用域来模仿。当然使用eval严格模式下的eval作用域也可以模仿。

***

### 私有变量

在ECMAScript中同样也是没有私有变量的，对于所有对象来说，对象的所有属性均是可以直接访问到的，是没有权限控制的。但是之前说过，函数是有其单独的作用域的。
函数内部的变量，在函数外是无法直接访问到的。

因此，在这里，我们可以说:**函数的参数，函数内部定义的变量，函数内部定义的其他函数** 都是**函数的私有变量**。

而我们把能访问这些函数内部私有方法，私有变量的公有方法叫做 特权方法。

我们可以使用以下两种方法来 创建一个自定义类型，该类型的所有对象实例都具备特权方法:
* 利用普通构造函数中创建特权方法:  这种方式，所有该类型的对象实例都具备一份自己的特权方法和私有属性。 **相互独立**。
* 在立即执行函数中创建具有特权方法的构造函数: 这种方式，所有该类型的对象实例都共享同一份私有属性，再通过原型链同享同一份特权方法。**高度共享**

而如果我们只是想**单纯地创建一个拥有特权方法的对象(这种对象已经可以叫做单例了)**而不是一个拥有特权方法的自定义类型,那么我们可以利用下面的方法:
* 立即执行函数返回一个对象,该对象具有访问该立即执行函数作用域中私有变量的特权方法。一一这叫作模块模式创建具有特权方法的单例对象

如果我们还需要该单例的类型信息，或者说，我们还需要这个单例是一种在已有对象基础上具有特权方法的单例，那么我们可以使用以下方法：
* 立即执行函数返回一个已有对象,该对象具有访问该立即执行函数作用域中私有变量的特权方法。一一这叫作增强模块模式
