/**
 * 由于开始对词法环境组件和变量环境组件理解不深。因此分析错误。
 */


/**
 * JS的具体实现中，with语句并没有按照规范来实现。 With语句内部的函数声明，甚至是变量声明依旧会影响到外部词法环境组件。
 */
(function () {
    var x=1;

    var a={x:2};

    console.log("foo:",foo,",bar:",bar);  //undefined

    with(a){
        function foo() {  //这里可以认为是浏览器将with语句中的函数声明当做了函数表达式赋值。当然规范上来说，statement语句中根本是不允许出现函数声明的。
            console.log(x);
        }

        var bar = function() {
            console.log(x);
        };

        foo();//2

        bar();//2
    }

    //在with执行完毕后，当前执行环境的词法环境组件中应当不包含 foo函数 和 bar函数对象。然而实际上，标识符依旧有效。
    //也就是说with语句内部执行的内容作用于词法环境组件，而这个内部的词法环境组件又作用于外部的词法环境组件。
    //这与规范中 外部词法环境组件保持不变是矛盾的。
    foo();//2

    bar();//2
})();

console.log("--------------");

/**
 * 上面的代码，如果严谨一点，我们其实可以清楚的知道，foo函数声明和bar变量声明其实在解析立即执行函数的声明式初始化时就已经拥有了标识符绑定了。
 * 因此 在with语句执行之前，foo和bar都是已经声明了的变量。但是这里就有问题了，var变量声明的确在变量环境中的初始值是undefined，但是函数声明在变量环境组件中的初始值
 * 应该是函数对象本身，但是上面却打印的是undefined。这个也是与规范不同的地方。我们可以倾向于认为。浏览器把statement语句中的函数声明当做了函数表达式的赋值。
 * 这样就解释的通为什么打印foo是undefined。 但是这依旧无法澄清一点:为什么with语句内部的改变影响到了外部词法环境组件的内容。
 */


/**
 * 为了更好的研究这个问题。我们使用eval语句。避免在statement中出现函数声明所导致的浏览器不同实现的"意外情况"。
 *
 * 这里我们认真的分析下整个流程中变量环境组件和词法环境组件。
 */
(function () {
    /**
     *在立即函数执行之时，会首先进行代码解析。 也就是声明式绑定初始化。
     * 此时 立即执行函数的 this绑定为全局对象。
     * 立即执行函数的变量环境组件以及词法环境组件为  env1，env2。数据相同。
     *      环境记录项:声明式. 内容x=undefined,a=undefined。
     *      外部词法环境:全局环境。
     * 从此 变量环境组件不变，而词法环境组件随着代码的执行会发生变化。
     */
    var x=1;

    var a={x:2};
    // console.log("foo:",foo,",bar:",bar);  很显然，会报错，因为目前来看立即执行函数的变量词法组件的声明式绑定初始化中根本没有foo,bar


    /**
     *在执行with语句之前，词法环境组件的内容为 x=1 a={x:2}。 env2
     * 而在执行with语句时，会新建一个词法环境env3作为执行环境的词法环境组件。
     *
     * 此时 立即执行函数的 this绑定为全局对象。
     * 立即执行函数的词法环境组件env3为
     *      环境记录项: 对象式 ,绑定对象:{x:2}
     *      外部词法环境:之前的词法环境env2
     * 而变量环境组件依旧不变为 env1.
     * 而eval语句会使用当前执行环境的词法环境组件和变量环境组件分别作为自身的词法环境组件和变量环境组件。
     * 根据函数产生式定义: 函数声明是使用当前执行环境的变量环境组件作为[[Scope]]。而函数表达式是使用当前执行环境的词法环境组件作为[[Scope]]。
     *
     * 因此，foo的标识符绑定是在eval函数内部声明式绑定初始化时完成，并赋值为foo函数对象。并且foo函数对象中的x应该是指向变量环境组件中的x,在这里也就是1
     * bar的标识符绑定在声明式绑定初始化时完成，并初始化为undefined，当在运行时函数表达式执行完毕并赋值后，为一个匿名的函数对象，并且该匿名函数对象中的x应该是指向词法环境组件中x，也就是2.
     *
     * 所以，eval函数的变量环境组件env1为声明式词法环境: x=1, a={x:2} ,foo:foo函数对象,bar:undefined
     * eval函数的词法环境组件env3为对象式词法环境，绑定对象{x:2,foo:foo函数对象，bar:undefined}
     */
    with(a){
        eval("        function foo() {\n" +
            "            console.log(x);\n" +
            "        }\n" +
            "\n" +
            "        var bar = function() {\n" +
            "            console.log(x);\n" +
            "        };\n");

        /**
         * eval函数执行执行完毕后,env1不变，env3的绑定对象变为{x:2,foo:foo函数对象，bar:bar函数对象}
         * 而在调用 foo和bar函数时，foo和bar函数内部也会创建一个执行环境，需要注意的是foo函数对象的[[scope]]是env1.bar函数对象的scope为env3
         * 并分别调用NewDeclarativeEnvironment(env1) NewDeclarativeEnvironment(env3)创建自己的声明式词法环境。并分别以这个新建的声明式词法环境作为变量环境组件和词法环境组件。
         * 在经历声明式绑定初始化后，由于没有变量声明没有函数声明没有形参，因此此时为该声明式词法环境中没有任何绑定。
         * 在执行各自的console.log(x)时，通过标识符解析，取用各自的词法环境组件寻找x取值。在调用GetIdentifierReference方法后，分别在其外部词法环境中寻找到x取值。
         */
        foo();//实际打印2    因此这里应该打印的是env1变量环境组件中的x一一也就是1

        bar();//实际打印2    因此这里应该打印的是env3词法环境组件中的x一一也就是2
    }

    /**
     * with语句返回后，词法环境组件变为原本的env2.而变量环境组件env1不变。
     * 此时解析foo和bar标识符。使用的是当前执行环境的词法环境组件env2调用GetIdentifierReference获取标识符信息。
     * 而这里。env2中是根本没有 foo和bar的标识符的。所以应当发生标识符解析错误。除非，变量环境组件env1中新增的标识符绑定会实时同步到词法环境组件env2中，并且伴随代码执行，env2中的标识符绑定依旧在更新。
     * 即便如此，这里也应该同上面一样理应分别打印  1和2。
     *
     */
    foo();//实际打印2  应当标识符解析错误

    bar();//实际打印2  应当标识符解析错误


    /**
     * 事后来看，以上分析建立在我对词法环境组件和变量环境组件理解正确的层面上。
     *
     * 除非！！！我关于词法环境和变量环境的理解是错误的！
     * 然而实际上在这个层面(变量环境不会变化，词法环境可能会变化)，的确我理解发生了错误。正确的理解 参看 变量环境组件和词法环境组件.js 继续夹带着with语句进行分析。
     */
})();



