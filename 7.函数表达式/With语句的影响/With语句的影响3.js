/**
 * 在规范上， with语句和函数声明本身也是存在冲突的一一当然最深层次的冲突来自于函数声明在块级语句中，通过eval。
 * 一方面，with语句的作用 会将语句内部的所有标识符默认主题对象为绑定对象。
 * 另一方面， 函数声明又要求在 变量环境组件中 访问标识符。
 * 那在with语句中的函数体内部的标识符到底是按照哪个来呢？ 规范并没有说明这种情况。
 *
 * 从这个角度来看，目前浏览器的实现其实是可以认为是， 在解析with语句函数体内部的标识符时， 隐式对象 覆盖了 词法环境组件。
 *
 * 当然从另一个角度讲，由于这种非顶层的函数声明本就属于规范未定义行为。
 * 因此这里将函数声明处理为函数表达式赋值，因此使用的是词法环境组件作为[[Scope]].这样来看的话，又是符合规范内容的。
 */
var a={b:{c:"a.b.c"}};
var b={c:"b.c"};

with (a){

    //因此，这里 (a.)b.c 实际上 访问的是 a.b.c, 只是 a作为隐式对象，被省略了
    eval("function foo() {\n" +
        "        console.log(b.c)\n" +
        "    }");

    //这里也就是我说的 显式this和隐式this的区别，在with语句中，显式的this和其他地方的this表现相同性质。
    //因为this是关键字，是不能当做属性的，所以 a.this.b.c.是不可能成立的，也就因此不会被解析为隐式对象的this.b.c属性。
    eval("    function bar() {\n" +
        "        console.log(this.b.c);\n" +
        "    }");
    foo(); // a.b.c
    bar(); // b.c
}

foo();  // a.b.c
bar();  // b.c


//以上分析 错误 或者说是 不完全正确。未考虑 ECMAScript中 .的特殊性。 对于这个例子的正确解释在 with语句的影响4.js 中。


