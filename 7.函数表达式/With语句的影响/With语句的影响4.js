/**
 * 对于with语句来说，对象式词法记录项的provideThis提供的隐式this的解释是不如 词法环境中解析标识符好的。
 */
(function () {
    var x=1;
    var a={x:2};
    var y="y";

    /**
     *此时 词法环境组件和变量环境组件env1的内容如下:
     * x -> 1
     * a -> {x:2}
     * y -> "y"
     * 外部词法环境引用->null
     */

    with(a){
        /**
         * 进入with语句后， 新建了一个对象式词法环境env2.内容如下:
         * x -> 2
         * 外部词法环境引用 -> env1
         * 此时变量环境组件为env1不变，词法环境组件为env2.
         */
        eval("    function foo() {\n" +
            "        console.log(y);\n" +
            "    }\n" +
            "    \n" +
            "    var bar=function () {\n" +
            "        console.log(y);\n" +
            "    }");
        /**
         * 执行完eval语句中。
         * env1或者env2中必定包含以下内容:
         * foo -> foo函数对象 y指向 变量环境组件env1中的y-> "y"
         * bar -> bar函数对象 由于词法环境env2中不具有 y 标识符，因此在其外部词法环境env1中寻找到了y的标识符绑定 y->"y"
         */
        foo();//打印 y
        bar();//打印 y
    }

    foo();//打印 y
    bar();//打印 y
})();

/*
 * 这种通过标识符解析的解释 显然比 隐式this更具有说服力。 因为规范中并没有说明 隐式this和词法环境的关系。
 * 在这里的情况就是:如果 y的解析是作为 a.y来解析的，那么显然a中没有y这个属性。
 * 如果当做解析成功:那么在ECMAScript中应该是当做 undefined来处理。但是实际并不输出undefined。
 * 如果当做解析失败，解析失败后呢？ 规范没说。
 */

console.log("--------------------");

/**
 * 我们再来说说 With语句的影响3.js 中犯的理解错误。
 */

(function () {
    var a={b:{c:"a.b.c"}};
    var b={c:"b.c"};

    with (a){

        /**
         * 这里实际上 只解析 标识符 "b" 而不是 "b.c"
         * 而当前的词法环境中恰好有 "b"的标识符绑定，因此选取的是 对象a上的b ，而词法环境的外部词法环境引用也就是变量环境上的b对象的c属性因此不会被标识符解析涉及到。
         * 为了说明只解析了 "b"，可以参看 标识符解析.js的例子
         */
        eval("function foo() {\n" +
            "        console.log(b.c)\n" +
            "    }");

        eval("    function bar() {\n" +
            "        console.log(this.b.c);\n" +
            "    }");

        foo(); // a.b.c
        bar(); // b.c
    }

    foo();  // a.b.c
    bar();  // b.c

})();


/**
 * 经过上面的一系列分析，我们可以发现， 浏览器绝对没有按照规范中的函数声明和函数表达式的[[SCOPE]]实现。
 * 一般而言，程序运行是不会出现这些情况的。因为一般而言，执行环境的词法环境组件和变量环境组件是同一个对象。因此函数声明和函数表达式的内部标识符解析最终都是在同一个对象中进行。
 * 但是，由于with语句的作用，导致了变量环境和词法环境不一致，从而产生了这个实现上的BUG。
 */