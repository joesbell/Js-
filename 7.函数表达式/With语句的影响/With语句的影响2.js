/**
 * 1.首先进行声明式绑定初始化。
 * 解析期间。 执行环境的词法环境组件和变量环境组件同时指向env1.
 * env1使用的是声明式词法环境记录项.具有以下记录.初始具备以下记录.
 * 标识符 x  -> undefeind
 * 标识符 a  -> undefined
 */

var x=1;
var a={x:2};

/**
 * 2.执行完以上代码后 env1记录如下：
 * 标识符 x  -> 1
 * 标识符 a  -> {x:2}
 */

/**
 * 3.进入with语句，此时会创建一个新的词法环境env2，这个词法环境以 a对象为绑定对象，是一个对象式环境记录项的词法环境。
 * 此时 执行环境的 变量环境组件为env1,词法环境组件为env2. env2词法环境的外部词法环境引用指向env1
 * 此时 env2词法环境的环境记录项内容为空
 */
with(a){

    /**
     * 执行eval语句时，会使用当前的词法环境组件和变量环境组件作为eval执行环境的词法环境组件和变量环境组件，
     * 因此 eval环境的词法环境组件为evn2，变量环境组件为env1.
     * env2的内容如下:
     * 标识符 x ->2
     *
     * eval的执行环境进行声明式绑定初始化后，
     * env1内容变更如下:
     * 标识符 x  -> 1
     * 标识符 a -> {x:2}
     * 标识符 foo -> foo函数对象 foo函数对象中的x是由变量环境组件中寻找的， 也就是 1.
     * 标识符 bar ->undefined
     *
     * 此时env2内容规范未规定，即是否会同步变量环境组件新增的标识符到词法环境组件上，在正常情况下，这两个组件为同一个对象，是自动同步的，但是此时已经不是同一个对象了，属于规范不涉及内容。
     */
    eval("\n" +
        "    function foo() {\n" +
        "        console.log(x)\n" +
        "    }\n" +
        "    \n" +
        "    var bar=function () {\n" +
        "        console.log(x)\n" +
        "    }");
    /**
     * 执行eval语句完毕后， 由于规范未涉及，这里只能说 env1或者(和)env2必定有以下内容
     * 标识符 bar -> 函数表达式产生的函数对象  其中x是由词法环境组件中寻找的，引用的是对象 a的 x属性 也就是 2
     */
    foo(); //解析foo，在词法环境env2中寻找不到，由此寻找其外部词法环境env1，找到并调用，理论上应打印 1， 实际打印2.
    bar(); //解析bar,在词法环境env2或者变量环境env1中找到并调用,理论上应打印 2， 实际打印2.

}

/**
 * with语句执行完毕后，当前执行环境的词法环境组件重置为env1。 需要注意的是这种情况下，env2并没有被销毁，因为存在 bar函数的闭包。
 */

a.x=3;
/**
 * 执行完毕后，此时变量环境组件和词法环境组件的env1内容如下.
 * 标识符 x  -> 1
 * 标识符 a -> {x:3}
 * 标识符 foo -> foo函数对象 foo函数对象中的x是由变量环境组件中寻找的， 也就是 1.
 * 标识符 bar -> 函数表达式产生的函数对象  其中x是由词法环境组件中寻找的，引用的是对象 a 的x属性 也就是 3
 */

foo(); //解析foo， 在词法环境env1找到并调用，理论上应打印 1， 实际打印3.
bar(); //解析foo， 在词法环境env1找到并调用，理论上应打印 3， 实际打印3.

/**
 *这个问题其实本质是由于 函数声明使用变量环境组件而导致的。 很明显，浏览器并没有如实按照规范实现函数声明。
 *而通过with以及eval，我们复现出了这个实现与规范不一致的现象。
 */

