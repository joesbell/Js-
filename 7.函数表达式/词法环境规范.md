
### 词法环境

词法环境是**ES5引入的新概念**。

词法环境是 **静态的**，当我们写好代码段以后，其所有的词法环境就被确定了下来。 

词法环境 是一个 底层规范实现的 抽象类型，用于处理 变量和标识符的指向问题，词法环境分为两个部分：

* 外部词法环境引用: 引用嵌套的外部的词法环境， 可能为空。比如全局代码段的外部词法环境就是空。
* 当前环境记录项: 用来记录当前代码段的标识符变量。起着ES3中变量对象和活动对象的作用。

***
    
### 环境记录项

环境记录项也是**ES5引入的新概念**，用来 **取代之前所说的 变量对象VO和活动对象AO**的概念。

所谓环境记录项，我们可以认为是对 执行上下文环境的 标识符绑定的记录。

环境记录项分为两种:
* 声明式环境记录项：记录 标识符与值直接绑定的语法元素。
    
    * var 变量声明
    * function 函数声明
    * catch包裹的对象

* 对象式环境记录项： 记录 标识符与对象的属性绑定的语法元素。
    
    * 代码段中的对象
    * with语句的对象

环境记录项具有**通用**的抽象方法:
* HasBinding( 标识符名 ) : 判断该环境记录项中是否拥有 某个标识符. 返回一个布尔值.
* CreateMutableBinding( 标识符名,是否可以删除) : 创建一个可变的标识符，该标识符能否被删除由第二个参数决定
* SetMutableBinding(标识符名,绑定的值,是否严格模式) : 绑定值到一个已存在的标识符上，如果 为严格模式并且该标识符不能被赋值,抛出 TypeError。
* GetBindingValue(标识符名,是否严格模式) : 获取已存在的标识符所绑定到的值。 如果绑定的值不存在或者没有初始化，并且是严格模式下，那么抛出 ReferenceError异常.  
* DeleteBinding( 标识符名 ) : 删除标识符。 如果标识符原本就不存在或者删除成功 返回true，否则返回false
* ImplicitThisValue() :  返回在这个环境记录中标识符绑定的函数对象 在调用时,this的取值。

需要注意的是，对于不同类型的环境记录项，其抽象方法的具体实现是不同的，也就是说规则是不同的。

#### 声明式环境记录项

声明式环境记录项是**与一个作用域相关联**的。

声明式环境记录具有额外的 抽象方法用于 **创建和初始化 不可变绑定的标识符**:
* CreateImmutableBinding( 标识符名 ) 创建一个 未初始化的 不可变绑定的标识符。
    
  如果当前环境下不存在该标识符的绑定，那么就创建一个 undefined初始值的未初始化不可变绑定。 
* InitializeImmutableBind( 标识符名，绑定值 ) 为 没有初始化的不可变绑定标识符 绑定一个 值。 

  如果该标识符存在并且是 未初始化的不可变绑定，那么就用该绑定值初始化这个不可变绑定。
  
声明式环境记录的抽象方法的 具体实现规则:
* HasBinding( 标识符名 )
 
  如果声明式环境记录(var function catch)具有这个标识符名，返回true
* CreateMutableBinding( 标识符名,是否可以删除)
    
  如果在当前记录中没有该标识符名，那么就在声明式记录中创建该标识符名，并且初始化为undefined。否则不执行。
* SetMutableBinding(标识符名,绑定的值,是否严格模式) 

  如果该标识符存在并且是可变绑定，那么修改其绑定的值。 否则，不会修改。 如果是在严格模式下，那么还会抛出TypeError异常。  
* GetBindingValue(标识符名,是否严格模式) 

  如果该标识符存在，并且该绑定不是一个未初始化的不可变绑定，那么返回其绑定的值。否则，即该标识符是未初始化的不可变绑定，如果在非严格模式下，返回undefined,否则抛出 ReferenceError。
* DeleteBinding( 标识符名 ) 

  如果该标识符不存在或者删除成功，返回true。 否则，表示该标识符是不可删除的标识符，返回false
* ImplicitThisValue() : 

  永远返回undefined
  
  
#### 对象式环境记录项

对象式环境记录项是**与一个对象相关联**的，这个对象也叫做绑定对象。

对象式环境记录项是直接将 **对象的属性名称**与 **标识符名称** 建立 一一对应的关系。 

对象的属性名称包含该对象所能访问到的一切属性，也就是说只要  prop in Obj 返回 true(自身的属性和通过原型链能访问到的属性),那么该属性名就会作为标识符名称建立绑定。
由于对象的属性的值是可以新增，修改，删除的，因此 对象式环境记录项是没有 不可变绑定的！

对象式环境记录的抽象方法的 具体实现规则:
* HasBinding( 标识符名 )
 
  如果该绑定对象或者该绑定对象的原型链上具有该标识符名的属性，返回true。否则返回false
* CreateMutableBinding( 标识符名,是否可以删除)
    
  如果该绑定对象及其原型链上不包含该属性，那么为该绑定对象新增该标识符名的属性，其值为undefined，并且该属性的特性描述符为{ value:undefined,enumerable:true,writable:true,configurable:是否可以删除}。
* SetMutableBinding(标识符名,绑定的值,是否严格模式) 

  如果该绑定对象及其原型链上的该属性不可写或者不存在，那么根据是否是严格模式进行错误处理。否则就使用 对象的\[\[Put]]方法设置绑定值。
* GetBindingValue(标识符名,是否严格模式) 

  如果该绑定对象及其原型链上该属性不存在，根据是否是严格模式抛出ReferenceError或者是返回undefined。 如果存在，那么就调用该对象的\[\[Get]]方法并返回。
* DeleteBinding( 标识符名 ) 

  如果该绑定对象自身上的该属性不存在或者删除成功，返回true。 否则，返回false
* ImplicitThisValue() : 

  在对象式环境记录项的 provideThis标识为false时，返回undefined，否则返回绑定对象。
 
***

### 词法环境的运算

词法环境的运算主要是 底层对词法环境的操作，总共有三种涉及词法环境的抽象方法.

* GetIdentifierReference(lex,name,strict)
  
  该方法**用于在lex词法环境中，获取标识符name所绑定的引用规范类型对象**。strcit表示是否是严格模式。
  
  其主要运算步骤如下：
  
  1.首先判断该词法环境是否为null，如果为null，返回一个 引用规范类型对象={BaseValue:undefined,ReferenceName:name,IsStrictReference:strict}
  
  2.如果词法环境不为null，那么在该词法环境下的 对象和声明式环境记录项中 使用 HasBinding(name)方法判断是否存在这个 标识符名name 的绑定。
  
  3.如果存在该标识符的绑定，那么返回一个 引用规范类型对象={BaseValue:该对象或者声明式环境记录项,ReferenceName:name,IsStrictReference:strict}
  
  4.如果不存在该标识符的绑定，那么令词法环境为当前词法环境的外部引用词法环境，再次调用本函数。(这里就有一种作用域链的感觉了)
     
* NewDeclarativeEnvironment(lex)

  该方法用于在lex词法环境下创建一个新的词法环境，并且该新的词法环境中包含一个**不包含任何标识符绑定的声明式环境记录项**。**也就是说，函数创建的词法环境和外部是毫无联系的，是全新的，除了词法环境的外部词法引用了外部词法环境**
  
  其主要运算步骤如下:
  
  1.新建一个词法环境，并包含一个 不包含任何标识符绑定的 声明式环境记录项。
  
  2.将该词法环境的外部词法引用指向lex。
  
  3.返回该词法环境。
  
* NewObjectEnvironment(BindingObject,lex)

  该方法用于在lex词法环境下创建一个新的词法环境，并且该新的词法环境中包含一个以BindingObject为绑定对象的对象式环境记录项。
  
  其主要运算步骤如下：
  
  1.新建一个词法环境，并包含一个 讲BindingObject作为绑定对象的对象式环境记录项。
  
  2.将该词法环境的外部词法引用指向lex。
  
  3.返回该词法环境。
  
***

### 全局环境

全局环境是一个**唯一的词法环境**，在所有ECMAScript代码执行之前就已经存在了。

并且，全局环境的 环境记录项是一个 对象式环境记录项，其绑定对象是全局global对象。


