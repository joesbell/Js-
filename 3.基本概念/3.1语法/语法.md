# EcmaScript语法

EcmaScript中一切都区分大小写。

### 标识符
变量，函数，属性，参数 就是标识符。 标识符有以下规则:
* 第一个字符必须是 字母，下划线 _ ， 或一个美元符号 $
* 其他字符可以是 字母，下划线，美元符号，数字

说明: 字母包含 ASCII或Unicode的字母。虽然不推荐这样做。


### 注释

单行注释：

    // 注释内容

多行注释:

    /*
     注释内容
    */

### 严格模式

严格模式是JavaScript定义的一种不同的解析和执行模型。在严格模式下，ECMAScript一些不确定的行为将得到处理，同时某些不安全的操作也会抛出错误。

使用严格模式的方式可以在脚本顶部添加以下代码:
> “use strict";

也可以在函数中添加，表示当前函数在严格模式下执行:

    function doSomething(){
        "use strict" ;

        函数内容


    }


以上只是简单的严格模式使用举例，实际上，严格模式是分为以下三种的，分别对应三种可执行代码类型：
* **全局严格模式代码**

  全局严格模式代码是指 **首行以 "use strict"** 开头的全局代码。
* **eval严格模式代码**

  eval严格模式代码分为两种情况:
  * 在eval代码段中，以 "use strict"开头的字符串作为参数，执行的代码。
  * 在全局严格模式代码中，**直接调用而非间接调用** eval函数执行的代码段。

* **函数严格模式代码**

  函数严格模式代码分为三种情况:
  * 函数声明时，函数声明所在的代码在严格模式下。
  * 函数声明中，函数体内部以 "use strict"开头。
  * new Function()创建函数对象时，传入的函数体字符串以 "use strict"开头，则该函数为严格模式代码。
    **这种Function构造函数创建函数对象的情况非常特殊，不受以上情况限制**。
    也就是说，这种情况是定性地创建 严格模式下的 或者 非严格模式下的 函数代码，而不受外部严格模式与否的影响，**不管这种影响是在创建时还是调用时**。

这就是完整的严格模式代码执行的规则。

由此，我们可以总结严格模式和非严格模式的**互相切换模式的联系**:
* 在严格模式下的执行环境中，也是可以执行非严格模式代码的,常用方法有以下三种
    * **间接调用eval函数**，即可执行 eval非严格模式代码。
    * 使用new Function() 创建函数对象，参数字符串不以"use strict"开头
    * 调用非严格模式函数代码(也就是声明在非严格模式代码段中，函数体不以"use strict"开头)。

* 在非严格模式下的执行环境中，也是可以执行严格模式代码的，常用方法有以下三种
    * 调用非严格模式代码段中函数体内代码以"use strict"开头的函数
    * 直接或间接调用eval代码，eval代码段中以"use strict"开头
    * 调用严格模式函数代码(也就是在严格模式代码段中声明或者函数体内代码以"use strict"开头的函数)。

我们必须要理解到，严格模式和非严格模式只是 两种不同的 解释和执行代码的方式。
**两者不可以 同一时刻 同时存在，但是在整个程序执行的生命周期里，却是可以互相切换从而同时具备两种模式的**。

在一段程序的整个生命周期内，严格模式下执行的代码产生的数据，一旦切换运行在非严格模式下，**数据本身是保持不变**，但是之后的代码执行的方式就是按照非严格模式下的规则来执行，反之亦然。
**而不是说，一旦某个数据在严格模式下产生，对该数据的所有操作就是按照严格模式的规则进行操作**，这一点非常重要。

此外，我们还必须注意一个细节，函数执行时是否是按照严格模式执行，**完全取决于函数声明时该函数是否为 严格模式函数代码**。
这里看似违背了上面我们总结的数据(在这儿是函数)本身保持不变,根据当前是否为严格模式来决定解释执行的规则的结论。实际上，这里可以这样理解，**当我们调用函数时，其实是跳转到函数声明所在的地方
进行逐行执行**，而这个操作，就可能引起解释执行模式的切换。所以，这种情况，恰恰证明了我们的结论。


#### HTML内联代码中的严格模式

HTML内联代码中的严格模式是比较特殊的，会有一些奇怪的情况。

        <sciprt>
            JS代码段1
        </sciprt>

        <sciprt>
            JS代码段2
        </sciprt>

        <sciprt>
            JS代码段3
        </sciprt>

HTML如果出现形如以上的JS代码段，也就是说，JS代码在不同的标签下，那么不同标签中的代码的执行模式是完全分割的。
也就是说，如果JS代码段1为全局严格模式代码，后面标签中的代码依旧是非严格模式下的代码一一尽管从逻辑上来说，他们都是整段程序的全局代码，使用的是同一个全局对象。


这里我个人的解释是这样的:

首先我们得明白的是，虽然这些代码段均是全局代码段，但是，这些代码**并不是一次性进行声明式绑定初始化的**。因为这些代码是按照顺序加载的。

退一步说，script标签同样可以引入外部js文件，而这些代码的加载与否，是不确定的。

浏览器在执行这些代码时，不可能等到所有的代码均加载完毕后再统一进行解释执行，这样就会带来一个问题，整个网站的JS代码会因为一个外部JS文件未被加载而不被执行，这是无法容忍的。

所以，浏览器的引擎在对待script标签下的内联代码时，是采用的这种策略：对不同标签下的内联代码按照顺序进行解释执行，在顺序靠前的标签的代码段中是无法感知到顺序靠后的标签的代码段的。

或者这样说，在**进行执行环境的声明式初始化时，是按照标签为单位进行的**，**顺序靠后的标签的初始词法环境和初始变量环境**是**顺序靠前的标签的代码段执行完毕后的词法环境和变量环境**。

由此带来的影响就是，前面标签内的代码段是无法访问后面代码段的变量和函数声明的，而后面标签内的代码段却可以访问前面标签中代码段**执行完毕后**存在的变量和函数声明。

一旦我们明白了这个原理，我们就可以轻松的理解为什么不同标签内的代码段的严格模式不共享的原因了:**因为他们是分标签地进行解释执行的，而解释执行的默认模式是非严格模式**。

同时这也是为了最大限度的兼容代码。因为严格模式是在ES5时才正式提出的，本着不影响老代码的原则，让严格模式仅仅限制在我们明确声明的标签的代码段中。

***

### 语句
ECMAScript中 每一个语句的结尾是由 分号; 标识。 如果没有添加; 那么由解析器来自动确定语句的结尾。



### **变量**

EcmaScript的变量是 松散型的。 变量可以保存任何类型的数据。可以说，变量只是一个用于保存值的占位符而已。

变量的定义:
> var(操作符) + 变量名(标识符);

eg:
> var message; //定义了一个 message变量

关于变量更详细的参看 js文件中的代码。
