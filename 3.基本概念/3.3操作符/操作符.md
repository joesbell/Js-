# 操作符

***

### 一元操作符
EcmaScript中 一元操作符有如下两种:
* 递增递减 操作符
* 一元 加减操作符

#### 递增和递减 操作符
对于递增递减操作符，和其他语言类似，均有副作用。即：

    num++ 和 ++num 在运算时影响不同。

与其他语言不同的是，EcmaScript会自动转换进行运算的数据。 也就是说， 递增和递减操作符不仅对
数值类型数据生效，也对Boolean,Null,Object，String，Undefined生效。
**其规则就是 Number()函数的规则。**

#### 一元加减操作符
一元加减操作符非常简单。
* +操作符 可以认为是对数据进行 Number(数据)  数值转换。
* -操作符 可以认为是对数据进行 Number(数据)  数值转换后进行取反。

***

### 位操作符

ECMAScript中所有数值都以IEEE-754 64位存储的。但是这64位存储对于我们来说是透明的，因为操作之前都会将
64位数据转换成32位的整数，然后执行操作，最后再转换为64位存储。

这个因素会导致一个问题：**NaN和Infinity在进行位操作时，是被当作0处理。**

#### & 按位与

其表如下:

| 第一个数值 | 第二个数值 | 按位与结果 |
|----------|----------|-----------|
|    1     |    1      |     1    |
|    1     |    0      |     0    |
|    0     |    1      |     0    |
|    0     |    0      |     0    |


#### | 按位或

| 第一个数值 | 第二个数值 | 按位或结果 |
|----------|----------|-----------|
|    1     |    1      |     1    |
|    1     |    0      |     1    |
|    0     |    1      |     1    |
|    0     |    0      |     0    |


#### ^ 按位异或

| 第一个数值 | 第二个数值 | 按位异或结果|
|----------|----------|-----------|
|    1     |    1      |     0    |
|    1     |    0      |     1    |
|    0     |    1      |     1    |
|    0     |    0      |     0    |

#### 左移 <<

对于 左移来说，是不会影响符号位的。 左移一位就等于 乘以2， 左移n位就等于乘以2的n次方。

eg:

     var num=4;
     num=num<<2;
     alert(num); //16

#### 有符号的右移 >>

对于 有符号的右移来说，是不会影响符号位的。 对于正数，高位用符号位0填充，对于负数，高位用符号位1填充。

有符号的右移n位，就等于是除以 2的n次方。

如果原本的位全被移完了，那么，右移操作后:
* 对于原本是正数的: 最终结果是 00000000000...0000，也就是 数值 0
* 对于原本是负数的: 最终结果是 11111111111...1111，也就是 数值 -1


#### 无符号的右移 >>>

对于 无符号的右移来说， **高位一律是填充0.**

因此对于原本是正数的数值来说， >>>和>>操作是等效的。

但是对于原本是负数的数值来说， 无符号右移>>> 则完全不同。只要进行一次无符号右移，负数就会变成正数，而且往往还特别大。

***

### 布尔操作符

布尔操作符有三个:
* NOT !
* AND &&
* OR ||

#### NOT ! 逻辑非

逻辑非的规则 等同于  Boolean(表达式) 取反的规则。

#### 两个短路操作符 AND &&  和 OR ||
对于这两个操作符只需要记住一点:**短路性。**

对于 **&&** 逻辑与操作符： 从左向右求值，只要遇到 **求值为false的表达式**就返回该**表达式本身**，
这也是为什么 逻辑与操作符不一定返回 布尔值的原因。 如果求值到最后一个表达式，那么直接返回最后一个**表达式本身**。

对于 **||** 逻辑或操作符： 从左向右求值，只要遇到 **求值为true的表达式**就返回**该表达式本身**，
这也是为什么 逻辑或操作符不一定返回 布尔值的原因。 如果求值到最后一个表达式，那么直接返回最后一个**表达式本身**。


***

### 乘性操作符

ECMAScript有3个乘型操作符:
* 乘法 *
* 除法 /
* 求模运算 %

同样的对于乘型运算符来说，运算的操作数不一定是Number类型，但是这些非Number类型的数据会被强制使用**Number()函数转型为Number类型参与运算。**

#### 乘法 *
针对乘法 只需要注意一下: Infinity*0=NaN

#### 除法 /

特别注意的是:
* **非0有限数除以0 返回的是 Infinity** ，符号由两者共同决定。
* **Infinity除以 任何有限数(包括0) 都返回 Infinity**，符号由两者共同决定。

#### 求模 %

针对求模，只需要记住:
* **8只要被除数是 Infinity，结果都是NaN**
* **只要被除数是 0，结果都是0。(除数为0时除外，此时等于NaN)**

***

### 加型操作符
ECMAScript有2个加型操作符:
* 加法 +
* 减法 -

但是需要注意的是，虽然运算的操作数不一定是Number类型，
但是对于这些非Number类型的操作数，
并不是一味地使用Number()函数进行转型，而是**针对不同情况进行不同的转型。**

#### 加法 +

对于 加法操作符来说，需要明确，分为两种情况：

* 没有引用类型时：
    * 操作数中有字符串
    * 操作数中无字符串
* 有引用类型时:**倾向于转化为基本类型进行运算。**

其规则一言概之:
* 在没有引用类型时:
    * 有字符串则使用**String()转型函数**转化为两个字符串进行拼接。
    * 没有字符串则使用**Number()转型函数**转化为两个数值进行加法操作。
* 有引用类型时，对引用类型采取以下方式处理:
    * **第一原则:优先选择valueOf，第二原则，优先选择自身的。即 选择优先级:自身valueOf > 继承valueOf > 自身toString > 继承toString**

    * 此时，我们必定可以挑选到 一个 valueOf 和一个 toString (不管是自身的还是继承的)

    * 如果调用valueOf获取基本类型成功，则使用该返回值，否则调用toString获取基本类型，成功则使用该返回值。**均失败**，则抛出类型转换异常。

当两个操作数 **均是** 数值时，进行加法操作,有以下特殊情况：
* Infinity+Infinity=Infinity
* -Infinity+(-Infinity)=-Infinity
* -Infinity+Infinity=NaN

另外还需要注意一点：  加性操作符 + 是**二元运算符**，具有**顺序性**，运算顺序**从左向右**。
因此下面两个表达式求值是不同的

    var num1=5,num2=10;
    console.log(num1+num2+"是5+10的结果"); //15是5+10的结果
    console.log("5+10的结果不是"+num1+num2); //5+10的结果不是510
    //如果想要改正确，那么应该使用括号提高其运算顺序。
    console.log("此时,5+10的结果是"+(num1+num2)); //此时5+10的结果是15


    
***

在学习完加法操作符规范以后，再来回顾我们曾经总结的规律

* 没有引用类型时：
    * 操作数中有字符串
    * 操作数中无字符串
* 有引用类型时:**倾向于转化为基本类型进行运算。**

**有无引用类型的本质区别:是否调用了ToPrimitive规范方法获取Object类型对象的原始值**

其规则一言概之:
* 在没有引用类型时:  (**没有获取原始值，因为本身就是原始值，所以遵从 String字符串进行连接操作， Number数字进行数值计算操作**)
    * 有字符串则使用**String()转型函数**转化为两个字符串进行拼接。 (**String()转型函数本质上就是\[\[ToString]]规范方法**)
    * 没有字符串则使用**Number()转型函数**转化为两个数值进行加法操作。(**Number()转型函数本质上就是\[\[ToNumber]]规范方法**)
* 有引用类型时，对引用类型采取以下方式处理:(**对于Object引用类型，我们必须通过ToPrimitive规范方法获取其原始值进行操作**)

    **在绝大多数情况下，由于ToPrimitive没有传递暗示类型，因此都是获取的对象的默认暗示类型的原始值一一也就是Date类型获取String原始值而非Date引用类型对象获取Number原始值**。其造成的影响如下:
    
    * 当对象为**非Date类型**时: 绝大多数情况
        * **第一原则:优先选择valueOf，第二原则，优先选择自身的。即 选择优先级:自身valueOf > 继承valueOf > 自身toString > 继承toString**
    
        * 此时，我们必定可以挑选到 一个 valueOf 和一个 toString (不管是自身的还是继承的)
    
        * 如果调用valueOf获取基本类型成功，则使用该返回值，否则调用toString获取基本类型，成功则使用该返回值。**均失败**，则抛出类型转换异常。
        
    * 当对象为**Date类型**时: 
        * **第一原则:优先选择toString，第二原则，优先选择自身的。即 选择优先级: 自身toString > 继承toString >  自身valueOf > 继承valueOf**
    
        * 此时，我们必定可以挑选到 一个 toString 和一个 valueOf (不管是自身的还是继承的)
    
        * 如果调用toString获取基本类型成功，则使用该返回值，否则调用valueOf获取基本类型，成功则使用该返回值。**均失败**，则抛出类型转换异常。
    
以上才是完整的加法操作符规则。


#### 减法 -

对于 减法操作符来说，简单许多，因为减法只具有 减法操作的能力，无法连接字符串，因此全程只需要进行 **Number()转型**即可。

如果遭遇引用类型，参考+加法运算符的转换规则,只不过在进行数值减运算时，由于无法像加法一样连接字符串，因此会返回NaN罢了。

需要注意的是，以下特殊情况:
* Infinity -  Infinity=NaN
* -Infinity - (-Infinity)=NaN
* -Infinity - Infinity=-Infinity
* Infinity - (-Infinity) =Infinity



***

### 关系操作符 < > <= >=

关系操作符 均返回一个 **布尔值**。

其原则一言概之: **优先 进行 数值比较， 除非转型过程中(对于对象来说)刚好能 进行 字符串比较。**

其详细规则如下:

1. 当**原始操作数**均是基本类型时:
* 当且仅当 两个操作数都是字符串时，进行字符串比较操作
* 其余情况，将原始操作数进行 **Number()** 转型后进行数值比较

2. 当**原始操作数**中有一个是对象时:
对象有valueOf()方法就返回valueOf()方法结果，否则返回toString()方法结果。
* 如果另一个操作数和返回的结果中有数值，那么就统一Number()转型进行数值比较。
* 如果另一个操作数和返回的结果均为字符串，那么就统一进行字符串比较。(**这就是刚好能进行字符串比较**)
* 除此之外的情况一律 统一Number()转型进行数值比较

3. 当**原始操作数**中均是对象时:
对象有valueOf()方法就返回valueOf()方法结果，否则返回toString()方法结果。
* 如果两个返回的结果中有数值，那么就统一Number()转型进行数值比较。
* 如果两个返回的结果均为字符串，那么就统一进行字符串比较。(**这就是刚好能进行字符串比较**)
* 除此之外的情况一律 统一Number()转型进行数值比较

4. NaN与一切操作数比较均是返回 false。 包含 NaN比较NaN.

另外需要注意的是，字符串比较规则是按照编码顺序决定的。并且是按位比较。

***

### 相等操作符 ==相等 ===全等

#### 相等== 和 不相等!=
这组操作符的原则是 **先转换,再比较**。

所谓**先转换**，即将不同类型的数据转换为**某种统一类型**。潜台词就是：如果两者类型原本就相同，那么就不用转换，直接进行比较即可。
引申出了第一条规则:
1. 如果两者类型相同，如果是**基本类型**就直接比较其值是否相同，如果是**引用类型(对象)**则比较是不是(指向)同一个对象。

而第二条规则则建立在两者数据类型不同的基础上:

2. 如果两者都是基本类型，那么直接使用Number()转型函数转为数值类型比较相等性。
如果有一者是对象，那么就调用对象的 **valueOf()方法**，用得到的值**当且仅当重复一次**1和2的规则。

**特别规则:**

3. ** null 与 undefined 是相等的。**  (这是规定)

4. 比较相等性之前，null和undefined不能转换为其他任何类型。

5. 操作数相等性比较过程中出现NaN时，结果都是**不相等**。(因为在1和2规则下，出现NaN时，意味着已经在进行数值的比较了，而NaN不等于NaN)


关于 规则2的 **当且仅当重复一次**的 解释:


     var data1=321;
     var data2={
         valueOf:function(){
             //返回的是一个对象。
             return {
                 valueOf : function () {
                     return "321";
                 }
             };
         }
     };
     result=data1==data2;  //false!!!! 重复规则时，不会再次调用valueOf()方法了，而是直接比较两个值是否相同。
                           //而在这里，显然 321和对象是不相同的。


在学习完抽象相等比较操作符规范以后，再来回顾我们曾经总结的规律,我们会发现**之前总结的规律是错误的**

所谓**先转换**，即将不同类型的数据转换为**某种统一类型**。潜台词就是：如果两者类型原本就相同，那么就不用转换，直接进行比较即可。

引申出了第一条规则:
1. 如果两者类型相同，如果是**基本类型**就直接比较其值是否相同，如果是**引用类型(对象)**则比较是不是(指向)同一个对象。(**这就是规范里 Type(x)和Type(y)相同时进行比较的情况，正确**)

而第二条规则则建立在两者数据类型不同的基础上:

2. 如果两者都是~~基本~~(更正)**原始值类型**(非Object的基本类型)，那么直接使用Number()转型函数转为数值Number类型比较相等性。 (**这就是规范里 类型不同但是均为原始值的情况下，进行\[\[ToNumber]]转换后比较数值的情况，原本表述不完全正确**)

~~如果有一者是对象，那么就调用对象的 **valueOf()方法**，用得到的值**当且仅当重复一次**1和2的规则~~。(**而这里就完全错误了**)
实际上，**对于Object类型和原始值的比较，是进行 \[\[ToPrimitive]](Object类型对象)获取的对象原始值与原始值进行比较**。

从某种意义上来讲，的确是当且仅当重复一次，不过这里的一次是指的是调用 \[\[ToPrimitive]]规范方法获取原始值。

我们以上面的代码来说明原因：

     var data1=321;
     var data2={
         valueOf:function(){
             //返回的是一个对象。
             return {
                 valueOf : function () {
                     return "321";
                 }
             };
         }
     };
     result=data1==data2;  
     //这里之所以返回false，并不是因为 不会递归地调用valueOf方法，而是在 ToPrimitive规范方法获取data2的原始值后，首先调用valueOf发现获取的是一个对象，并非原始值，
     //所以调用toString方法尝试获取原始值，在这里是调用原型链上Object.prototype.toString方法，获取到原始值 "[object Object]" 并与 321 进行比较发现不相等。
     //要证明这个结论非常简单.
     data1="[object Object]";
     console.log(data1==data2); //true 
     

#### 全等 === 和 不全等 !==
这组操作符的规则是 **只比较，不转换**.

因此规则特别简单。

全等成立的**唯一条件**是: 在**类型相同**的前提下，如果是基本类型，则必须值相同，如果是对象，则必须是同一对象。

反之，则是 不全等成立的条件了。

需要注意的一点是 **NaN依旧不全等于NaN**，因为NaN的值和NaN自身也不相同。

***

### 条件操作符(三目运算符)  exp ? exp : exp
三目运算符的使用和其他语言一样。这里就不作解释了。

***

### 赋值运算符 = 以及加强的 复合赋值运算符。

复合赋值运算符和其他语言一样：

    num1*=num2; 等价于-------> num1=num1*num2;
    num1+=num2; 等价于-------> num1=num1+num2;
    num1-=num2; 等价于-------> num1=num1-num2;
    num1/=num2; 等价于-------> num1=num1/num2;

    ...以此类推

***

### 逗号操作符 ，
可以在一个语句中执行多个操作，一般用于变量声明并赋值的时候使用.

>>eg: var a=1,b=2,c;

也可以这样使用:

>>eg: var a=(1,2,3,5);  // 最终a被赋值为5

***