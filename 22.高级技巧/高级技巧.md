# 高级技巧

### 高级函数

#### 安全的类型检查

在脚本中，我们想要判断一个变量是什么类型的，我们可以使用**typeof**操作符和**instanceof**操作符配合来检测一个变量的值的类型。

但是，这存在着问题:
* 某些版本的浏览器进行typeof 操作可能返回错误(或者说是不合规范)的值，也就是说，typeof操作符对于某些浏览器来说，是不可靠的。 
* 对于跨文档(也就是说存在多个全局作用域)的类型检测，由于不同文档的Object对象不全等，因此使用instanceof操作符同样会出现问题。

而安全的类型检查，则是利用了 **Object.prototype.toString** 方法。

按照规范，Object.prototype.toString方法遵循以下步骤:
* 如果 this 取值为 undefined 时， 返回 字符串 \[object Undefined\]
* 如果 this 取值为 null 时， 返回 字符串 \[object Null\]
* 对this使用ToObject抽象操作，基本类型非undefined非null时转化为其包装类型。 最后得到对象O
* 令 class 为 对象O的\[\[Class]]规范属性的值。
* 返回字符串 \[object class\]

通过这种方式，我们只需要根据 Object.prototype.toString.call(variable) 的返回值，就可以判断出该变量是什么类型的数据了。当然，这个方式**只能判断数据类型，而不能判断继承关系**。

并且，由于每个浏览器(除了IE低版本使用COM组件)实现**原生的类型**都必须遵循规范，因此，就算是跨文档的类型检测，也毫无问题。

但是需要注意的一点是，这种Object.prototype.toString方式实现的安全的类型检测**只能检测原生的类型**，因为只有**原生的类型内部class才有预设的特殊值用来分辨彼此**:
* null 内部class就是 "Null"
* undefined 内部class就是 "Undefined"
* String包装类型 内部class就是 "String"
* Number包装类型 内部class就是 "Number"
* Boolean包装类型 内部class就是 "Boolean"
* Object类型 内部class就是 "Object"
* Function类型 内部class就是 "Function"
* JSON类型 内部class就是 "JSON"
* RegExp类型 内部class就是 "RegExp"
* Array类型 内部class就是 "Array"

任何我们自定义的对象Object.prototype.toString的结果都是当做Object类型来处理，也就是说返回值为 \[object Object\]。

***

#### 作用域安全的构造函数

所谓作用域安全的函数，本质上就是利用 **instanceof** 操作符来判断 当前this是否是构造函数创建的对象，如果不是，那么就返回正确的构造函数调用结果。以此来达到不污染其他作用域的目的。

这种污染其他作用域的例子多见于 **直接调用 构造函数** 而不是 使用 **new 关键字** 调用构造函数。

使用作用域安全的构造函数在继承时可能出现问题，如果子类是**直接通过借用构造函数**的方法来继承父类的属性，由于 instanceof检测的存在，除非子类和父类在原型链上有关系，否则，子类对象并不能继承父类的属性。

解决方式就是**手动修改子类的原型链**，使其和作用域安全的构造函数的类型连接起来。此时就能通过instanceof检测，并使用借用构造函数的方式为其子类对象初始化父类属性。

***

#### 惰性载入函数

这里所谓惰性载入函数,就是指的是根据宿主环境的不同,**动态地在运行时修改函数**的方法。

惰性载入函数的方式有两种:
* 在函数第一次执行时动态载入正确的函数
* 在函数声明时就动态载入正确的函数

后者虽然第一次加载会慢点，但是在第一次调用时可以保持更高的性能。

***

#### 函数绑定

函数执行时，其内部的this取值和调用方式有关系。

如果我们想要让一个函数在任何调用中执行效果都一致,那么我们需要进行函数绑定。

手动实现函数绑定的方式其实很简单，核心在于**保存this取值**。

ES5后在Function类型上提供了call apply bind 等方法，原生提供了函数绑定的实现。

ES6后提供了箭头函数，可以自动将箭头函数内部的this取值绑定为箭头函数定义时的执行环境中的this取值。

***

#### 函数柯里化

函数柯里化也叫做**函数部分求值**，表示的是给函数**分步传递参数**，并**返回一个更具体的函数接受剩下的参数**。

函数柯里化的过程就是逐步固定参数值的过程，在这个过程中，函数的**通用性降低**，但是**复用性提高**。

本质上，柯里化是一种**动态生成函数的方式**。

我们需要知道的是，柯里化必定是有限步骤的操作，其上限由**最初的函数的参数列表长度**决定。

利用柯里化，我们可以达到以下效果：
* 函数参数固定 这是柯里化最核心的作用，
* 函数延迟计算 将多元函数调用变为链式的单元函数调用 add(a,b,c) => add(a)(b)(c)

***

#### 函数反柯里化

函数反柯里化的过程和柯里化的过程是完全相反的，反柯里化的作用是将**原本只有特定类型能使用**的方法**扩展到任何对象都能使用**。提高**函数的通用性**。

函数反柯里化是有条件的，必须函数本身的处理方式是**鸭子类型**的。否则就算反柯里化后，依旧无法被其他对象所使用。

所谓鸭子类型，指的是不关注数据的类型，而是关注数据如何使用。 数组类型的slice等方法就是标准的鸭子类型的函数，正因为是鸭子类型的函数，所以我们才能不仅仅对数组类型使用slice方法，对类数组对象同时可以使用slice。

此时我们就能发挥出反柯里化的用途了，平常的我们需要不停使用Function.prototype的call apply等方法，而现在我们可以直接将这些 鸭子类型的函数 直接反柯里化后使用，省去了很多麻烦。

反柯里化的本质是将 obj.method(...args)式的函数调用转化为 method(obj,...args)式的函数调用。 也就是说将 对象 和 方法 剥离开来，以提高方法的适用范围。

***

### 防篡改对象

以前说过，ES属性的特性\[\[Enumerable]],\[\[Configurable]],\[\[Writable]],\[\[Value]],\[\[Set]],\[\[Get]]是可以通过Object.defineProperty方法来修改的。

但是为了防止这种方式来自由地重定义来修改属性的特性，这样就可以防止对象被篡改。 

***

#### 不可扩展对象

所谓扩展，是指**为对象添加属性和方法**。

在对象中具有一个 \[\[Extensible]]内部属性,这个属性就决定了对象是否可以添加属性或者方法，这个属性是无法直接访问到的。

ES5提供了以下方法用于操作这个内部属性:
* **Object.isExtensible(obj)** 返回该内部属性\[\[Extensible]]的值。 如果为true表示可以扩展的。
* **Object.preventExtensions(obj)** 将内部属性\[\[Extensible]]设置false，也就是说将obj对象设置为不可扩展的。

这里需要注意的是:
* 默认的所有对象的 \[\[Extensible]]内部属性值都是true，也就是说都是可以扩展的。
* 只有通过Object.preventExtensions(obj)方法才能将对象设置为不可扩展的，并且一旦设置后，就**不能再变为可以扩展的对象了**。
* 扩展只能影响为对象 **新添加**属性或者方法，**不会影响修改**原有属性或者方法，也**不会影响删除**原有属性或者方法。
* 不仅通过赋值新增属性会被影响，而且**通过Object.defineProperty定义新增属性也会被影响**。

***

#### 密封对象(不可配置对象)

所谓密封，是指让对象变的封闭，**不可配置(configurable)**。

密封对象是对不可扩展对象的进一步限制，再不可扩展的基础上：
* 不允许对象**通过重定义的方式修改属性的特性**
* 因为\[\[configurable]]内部特性的值为false，因此属性和方法也是**不能被删除**的。

例外的是，不可配置对象并不是所有特性都不允许更改，在数据属性中，**如果writable特性为true，则value特性和writable特性依旧是可以重定义的**。

ES5提供了以下有关密封对象的方法:
* **Object.seal(obj)**  让obj对象变成不可配置的对象。
* **Object.isSealed(obj)** 返回obj对象是否是不可配置的对象。

对于 Object.seal(obj)方法来说，规范流程如下:
* 如果obj不是一个对象，那么直接抛出TypeError异常
* 否则对obj的每个**自身属性**设置其\[\[configurable]]值为false
* 设置其 \[\[Extensible]] 内部属性为false。(等同于 Object.preventExtensions(obj))
* 返回obj对象。

因此可以看出，不可配置对象仅仅只是在不可扩展对象的基础上多了一个 configurable特性为false而已，这个限制使得**对象的属性不能被删除也不能被重定义**。

***

#### 冻结对象

所谓冻结，是指让对象**不可做出任何更改**。

冻结对象是最多限制的防篡改对象，在不可扩展以及不可配置对象的基础上，还不允许更改对象已有的属性或者方法的值。

ES5提供了以下有关冻结对象的方法:
* **Object.freeze(obj)**  让obj对象变成冻结的对象。
* **Object.isFrozen(obj)** 返回obj对象是否是冻结的对象。

对于 Object.freeze(obj)方法来说，规范流程如下:
* 如果obj不是一个对象，那么直接抛出TypeError异常
* 否则对obj的每个**自身属性**设置其\[\[configurable]]值为false (等同于Object.seal(obj))
* 如果该属性还是**访问器属性，\[\[Writable]]特性也会被设为false**
* 设置其 \[\[Extensible]] 内部属性为false。(等同于 Object.preventExtensions(obj))
* 返回obj对象。

可以看出来，冻结对象是在不可配置对象的基础上，额外多了一个设置数据属性的writable特性为false而已，这个限制使得**对象的已有属性或者方法无法更改**。

但是这里要特别说一点，**对象的访问器属性依旧是可以赋值并执行set函数的**。

***

这上面所说的三种防篡改对象，按照**限制操作的范围**来看，从小到到依次为:
* 不可扩展  只是不能新增属性。
* 不可配置  前者基础上，还不能删除属性和重定义属性的特性。
* 冻结     既不能新增属性，也不能删除属性和重定义属性的特性，还不能更改已有属性的值。

*** 

### 高级定时器

在说定时器之前，我们首先要明确一点，JavaScript是个单线程的语言，同一时间只能有一段代码在执行。

在JavaScript代码执行的过程中，会不停的从**代码队列中获取新的代码**来执行。而定时器实际上就是将要执行的代码在**某个时间之后推入代码队列**中。

而推入代码队列之后，**不代表一定会立即执行**，因为代码队列前面可能还存在着其他代码，只有当前面的代码均执行完毕后，后面的代码才会执行。

***

#### 重复的定时器

当我们不停的利用setInterval定时器向代码队列中推入代码时，会出现两个问题:
* **间隔可能被跳过**，也就是说，到了时间点本该推入代码到队列中却没有推入。(这是由于setInterval推入代码的机制决定的:**当队列中已有该定时器的完整代码并且该完整代码还未执行，此时就不会推入当前定时器的代码到队列中**)
* 定时器的**代码执行间隔时间可能比预期的间隔小**。

我们假设 一个定时器间隔是200ms，但是这个定时器代码片段执行却要405ms才能执行完毕。

当0ms时，定时器代码片段1被推入队列并执行，当200ms时，由于队列中并没有相同的定时器代码，所以定时器代码片段2也被推入队列，由于代码片段1还没执行完毕，所以此时代码片段2不会执行依旧在队列中。

当400ms时，定时器代码片段3**准备被推入队列**，由于此时队列中有完整的代码片段2，所以在setInterval机制下，并不会将代码片段3推入队列，此时，一个间隔就被跳过了。

当405ms时，代码片段1执行完毕，此时代码片段2就可以开始执行了，此时前后两个定时器代码片段的执行间隔时间只有5ms，比预期的代码执行间隔200ms小。

为了避免setInterval定时器的这两个缺点，我们可以重复使用setTimeout。重复使用setTimeout能**保证两段定时器代码的执行间隔至少是我们预期的值**。

无论怎么说，当我们需要不间断的执行定时器代码时，最好是选择使用setTimeout来模拟setInterval。

***

#### Yielding Processes 定时器数组分块技术

前面说过，JavaScript是个单线程的语言，因此如果有一段程序执行时间过长，那么后续的代码就无法在短时间内被执行到了，同时如果一段代码运行超过一段时间，浏览器会白屏并停止响应，这种情况不是我们希望看到的。

为了解决单段代码执行过长的问题，就有了 Array Chunking 数组分块技术，首先需要明白的是，这种技术仅限于在以下情形使用:
* 代码允许**异步地执行**
* 数据**不严格要求顺序执行**
* 代码模式可以改造为**数组循环模式**

只要满足以上三点，那么我们就可以把执行时间过长的代码利用数组分块技术分拆开来执行。

需要注意的是，使用数组分块技术往往都会使得**代码的总执行时间变得更长**，唯一的优点就是使得页面不至于假死。

***

#### 函数节流throttle与函数去抖debounce

函数节流和函数去抖的目的都是为了减少频繁的函数调用。 

频繁的函数调用通常发生在以下情景中:由于频繁触发事件，比如resize事件，鼠标事件等。此时就需要利用定时器来进行函数节流和函数去抖来减少函数调用了。

所谓节流，就是指的是节制流入和流出，也就是说，在**一定时间段内限定流量**。 放在函数节流中，就是指的是 **使一个函数在一定时间内只能触发一次**。

通过定时器，如果**在间隔时间**内函数再次被调用，此时就清空上次调用，并将**剩余时间作为新的时间**执行定时器代码。我们可以认为这是一个冷却时间的概念。

函数节流一般用于**限定一定时间内只能执行一次函数**的时候使用。

比如窗口resize时，会触发频繁的resize事件，如果每次事件都进行处理，那么性能会急剧下降，而通过函数节流，我们就可以极大的减少resize事件的事件处理函数的执行次数，这个执行次数只跟 **resize操作的总时间以及设置的间隔时间**有关。

所谓函数去抖，指的是防止用户的多次频繁操作而导致每次都执行函数，导致脚本不停执行使得性能下降。

通过定时器，如果在定时器设置的**延时时间内**，函数又被调用，此时就清空上次调用，并**重置时间**执行定时器代码。当且仅当**在延迟执行时间内函数不再被调用过，此时函数才会在延时时间后真正的执行**。

函数去抖一般用于**减少不必要的函数执行，在真正需要的时候执行函数**。

比如用户输入字符串进行搜索，如果每次输入一个新的字符都进行搜索，那么性能就会下降。而通过函数去抖，我们就能在用户停下输入的时候或者用户输入间隔时间较长的时候才进行搜索，这才是搜索功能有价值的时刻，因此减少了不必要的函数执行。

***

### 自定义事件

这里所说的自定义事件不再是原生的Event事件了，而是一种**观察者的模式**。

这种模式能使得代码更加松散耦合，其核心原理是**创建一个管理事件的对象**。

这个对象非常类似于 EventTarget 类型，具有以下三个方法:
* 为自定义事件对象添加监听回调函数的方法。
* 为自定义事件对象移除监听回调函数的方法。
* 为自定义事件对象触发某个事件的方法。  

通过这个自定义事件对象，我们可以在**非DOM元素中使用自定义事件机制**。

***

### 拖放

在HTML5提供原生拖放功能之前，实现拖放的唯一方式就是利用**鼠标事件以及绝对定位**来进行模拟。

在进行模拟时，并不能直接将元素的位置设置为鼠标的位置，我们需要对拖动效果进行修缮，核心就是要**获取鼠标位置和元素位置初始时的偏移差**。

在模拟拖放功能的过程中，为了使得代码更加松散耦合，我们可以为模拟拖拽添加自定义的事件。其核心是**创建一个类EventTarget对象**。