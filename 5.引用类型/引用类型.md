# 引用类型

引用类型是一种数据结构，用于**将数据和功能组合**在一起。

从某种程度上来说，ECMAScript中的引用类型与C中的结构体struct的定义形式非常相似，因此我们通常不称呼引用类型为类。

ECMAScript中的对象更多的是类似于一种哈希表键值对的形式，是某个特定引用类型的实例。

下面就介绍一些常用的ECMAScript中的引用类型。

***

### Object类型


##### 创建Object引用类型实例
创建Object类型的方式有两种:

* new Object() 

* 对象字面量表示法

这里只单独说明对象字面量表示法.对象字面量表示法类似于下列形式:

    var person={
        name: "reveur",
        age: 23
    };
    
我们对于字面量表示法需要明白的是，**属性名本身就是字符串**，只是可以省略罢了，其实以上声明完全等价于下列声明：
 
    var person={
        "name": "reveur",
        "age":23
    };

省略属性名字符串的写法会在后台自动将起转化为字符串，因此大体上使用是没有区别的。 出现区别的地方在于某些特别的情况，
比如说属性名中出现空格，这时，如果不显式地指明属性名为字符串，那么是会报错的。


##### 访问实例的属性

访问对象属性的方式也有两种:
 
 * 点表示法 (最常用)
 
 * 方括号表示法(功能更强大)
 
在一般情况下我们访问对象的属性都是用的是点表示法,
所谓点表示法,就是使用 **对象.属性名** 来访问对象的属性的方式,如下所示:
>> person.name="reveur"; //这就是点表示法 对象.属性名的形式
 
而有些情况下，我们却只能使用方括号表示法，因为方括号表示法更加强大。
所谓方括号表示法,就是使用 **对象\["属性名"]** 来访问对象的属性的方式,如下所示:
>> person\["name"]="reveur"; //这就是方括号表示法 对象\["属性名"]的形式
 
在某些情况下，只能使用方括号表示法来获取对象的属性:
 
* 属性名不符合ECMAScript中对象属性名的一般要求:
    * 第一个字符必须是 字母,下划线_ ,美元符号$
    * 其余字符可以是 任意字母,数字,下划线_ ,美元符号$
    
    实际上对象的属性名还可以是;
    * 以数字开头
    * 属性名中具有空格等特殊字符
    
    对于这些不符合一般要求的属性名只能通过方括号表示法访问。
 
* 通过存储属性名的变量来访问对象属性
比如我们知道变量a是存储属性名的变量，这个时候如果我们用点表示法 对象.a  获取到的属性是 对象上"a"字符串所对应的属性，只有通过 方括号表示法 对象[a] 才能获取到真正想要获得的属性。
 
***
 
### Array类型
ECMAScript中的Array类型代表着数组，特别的是，ECMAScript中的Array数组的每一项的类型可以是任何类型，并且是动态增长的数组。


##### 创建数组

创建数组的方式有两种：

* 构造函数式

    使用构造函数来创建Array数组时，是**可以省略 new 操作符**的.
>> new Array() 和 Array() 都是创建一个新的空数组的方式。
* 数组字面量表示法
>> 数组字面量创建数组的方式就是这种形式: \["reveur",23,null,true]

对于Array数组，我们还需要知道的是:
var array=new Array();
* 对 array.length 属性的修改会影响到 array所存储的项数。
* array\["字符串"] 的方式也可以为数组添加项数或者属性。
    * 当字符串为纯数字时，等同于 array\[纯数字],此时会影响到数组的项数和长度
    * 当字符串非纯数字时，等同于 向array对象添加一个属性，就跟普通的对象的属性增加一样

##### 检测是否是Array类型

一般而言，检测一个对象是不是某个引用类型的实例的方式是使用instanceof操作符:
>> 对象 instanceof 引用类型

但是，在某些特殊情况下，比如说使用了HTML中的frameset框架，这个时候不同的框架的Array构造函数是不同的，
因此此时可以认为不同框架的 Array类型并不是同一个引用类型。这个时候想要辨别一个对象是否是Array引用类型的实例
只有通过 **Array.isArray(待检测对象)** 来判断了。

#### 方法

##### 转换方法

数组的常用转换方法主要有三种，其中两种都是转化成字符串的:
* valueOf() 返回自身数组对象
* toString() 返回对每一项调用toString()方法并用逗号分割的字符串
* toLocalString() 返回对每一项调用toLocalString()方法并用逗号分割的字符串

特别地,对于**取值为null或者undefined的项**，在返回字符串时取值为 **空字符串**。

##### 栈方法

ECMAScript的数组可以当作栈来使用，具有栈的特性 先进后出FILO,其方法为:
* push(元素) 将元素添加到最后一项，并返回数组此时的长度
* pop()     将数组的最后一项删除并返回该项元素。

##### 队列方法

EMCAScript的数组也可以当作队列使用，具有队列的特性 先进先出FIFO，其方法为:
* push(元素) 将元素添加到最后一项，并返回数组此时的长度
* shift() 将数组的第一项删除并返回该项元素。

如果要使用反向队列,那么其方法为:
* unshift(元素) 将元素添加到数组的第一项的位置,并返回数组此时的长度。
* pop()     将数组的最后一项删除并返回该项元素。

##### 重排序方法

ECMAScript的数字自带两种重排序方法:
* reverse() :直接将数组的元素反转。
* sort(可选的比较函数) 按照 传入的比较函数对数组进行排序。默认的情况是将每一项进行**String()转型后的结果**按照**ASCII编码升序排序**。

仅对于**sort方法**，有个特别的值**undefined,在排序后永远都是排在最后**。

比较函数接受两个参数，如果第一个参数位于第二个之前则返回负数，相等返回0，否则返回正数。

##### 操作方法

操作方法主要有3种:
* concat() 用于将接受到的参数添加到**数组副本**的末尾并返回这个新的副本数组。如果接受到的参数里包含有数组，
那么是将其逐项添加到数组副本的末尾。

* slice(start,end) 基于数组的[start,end)项返回一个新数组。 没有end参数则默认end为数组长度。

* splice(起始索引,删除几项,插入的元素) 需要注意的是，splice方法是对原数组进行操作的。


##### 位置方法

位置方法有两个:

* indexOf(元素，可选的起始项索引) 从起始索引位置**向后寻找**与元素相同的项，如果找到了就返回项的索引，否则返回-1.

* lastIndexOf(元素，可选的起始项索引) 从起始索引位置**向前寻找**与元素相同的项，如果找到了就返回项的索引，否则返回-1.
需要注意的是，这里的相同是使用的 全等=== 判断是否相同。


##### 迭代方法

数组的迭代方法都接受两个参数:
* 必须的 在每一项上运行的函数

  这个函数的参数如下:
  * 当前项的值 item
  * 当前项在数组中的索引 index
  * 数组对象本身 array
* 可选的 运行该函数的作用域对象(this取值)

迭代方法一共有5种:
* every():如果对数组的每一项运行该函数均返回true，则返回true。 **&&**
* filter():对数组的每一项运行函数，返回 **结果为true的数组的项所组成的数组**。
* forEach():对数组的每一项运行函数，**没有返回值**。
* map():对数组的每一项运行函数，返回**每次函数返回值所构成的数组**。
* some():如果对数组的每一项运行函数，其中有返回true的项，那么返回true。 **||**

需要注意的是，迭代方法**一般不会改变原本的数组项**的。

之所以是一般，是因为我们可以认为 传入的运行函数的第一个参数:**item 是每次从array数组中根据index传参进去的。**
而函数的传参是值传递，因此**对item重新赋值并不会影响到原本数组**，当然对item调用方法或者增加属性修改属性却可以
影响到原本数组的项，前提是这个项是引用类型的。因此一般而言，除非直接在函数中操作array对象，不然是不会影响到原数组的。

##### 归并方法

归并方法均接受两个参数:

* 必须的 归并函数。

    归并函数接受4个参数:
    * 之前的归并结果 prev
    * 当前的项的值 cur
    * 当前的项的索引 index
    * 数组对象本身 array

    需要注意的是，归并函数返回的值会被当作下一次的prev取值，当有 归并初值时，prev初值就等于 该初值。

* 可选的 归并初值。

归并方法有两个:
* reduce(归并函数，可选初值) 从起始项向后运行归并函数。 并返回最终归并结果。
* reduceRight(归并函数，可选初值)  从最后一项向前运行归并函数。 并返回最终归并结果。

***

### Date类型

在说Date类型之前必须明白一点。在计算机中存储的时间一般都是以
从 格林尼治 1970年1月1号0点 到现在的格林尼治时间 **所相差的毫秒数**来存储的。

计算机眼中的**同一个时刻**，那么其**毫秒数一定相同**:
由于各地时区不同，因此本地时间大家都不相同，但是其本质的本地时间不相同的原因，正是因为时区不同，
因此我们可以说 **本地时区影响的只是 时间 的表现形式**，想要真正的修改时间，必须修改其毫秒数。

##### 解析时间为毫秒值

Date类型具有两个将 日期格式解析为 表示时间的毫秒数的方法:
* Date.parse(时间格式的字符串)

  parse方法是将 时间格式的字符串当作 **当前时区的时间表现形式**，从而生成一个毫秒数的。

* Date.UTC(**年**(必须的),**月**(必须的),日,时,分,秒,毫秒)

  UTC方法却是将 时间格式当作 **标准GMT 0时区的时间表现形式**来看待的，从而生成毫秒数。

##### 构造函数

而Date的构造函数有三种类型:
* 接受一个毫秒数，并生成该毫秒数所代表的日期对象。

* 接受时间格式的字符串，并生成该时间格式字符串所代表的日期对象。

    需要注意的是，本质上Date构造参数依旧是一个毫秒数，只是后台自动调用了 Date.parse()方法
    解析了这个时间字符串，因此，这个日期对象是 **该字符串所代表的时间在本地时区下的表现形式** 的日期对象。
    并不是UTC标准时间。

* 接受类似UTC方法的参数，并生成该时间参数所代表的日期对象。

    这里也是将 时间参数当作是在本地时区下，而生成的日期对象。

因此,如果你真想要获取某个标准GMT时间的日期对象，那么只能通过 Date.UTC(时间参数)先获取毫秒数，再毫秒数传入 Date的构造函数。
其他所有的方式，获取到的时间都是基于本地时区的。

>> 比如想要获取 2000年1月1号0点的 标准时间的日期对象，我们只能使用 new Date(Date.UTC(2000,0))获取。
>> 如果使用 new Date(2000,0),生成的是在我们东8区的2000年1月1号0点的日期对象，实际标准GMT时间却代表着 1999年12月31号16点.

另外还有一个 Date.now()方法返回当前时间的毫秒数。同一时刻，在任何时区调用该方法，返回的毫秒数都是一致的，
正如我们最开始所说的，时间的毫秒数只有一个，不同的只是 该时刻在不同时区的表现形式。


### 继承方法
Date类型继承了Object类型的方法：
* toString() 返回带有时区信息的本地时间字符串
* toLocaleString() 按照本地区域格式，返回本地时间的字符串
* valueOf() 返回存储该时间的毫秒数表示。


关于Date类型的其他方法，根据方法名就能明白其作用。这里就不再讲述了。
唯一需要知道的是带有UTC的方法都是设置或者获取标准GMT时间。

***

### RegExp类型

ECMAScript中创建正则表达式对象的方式有两种:
* 正则表达式字面量  / pattern / flags

    正则表达式的flags有以下三种:
    * i 忽略大小写
    * g 全局匹配，而不是只匹配一次就结束。
    * m 多行匹配
* 构造函数 new RegExp( pattern字符串 , flags字符串 )

在使用正则表达式时,对于一些特殊字符要使用 反斜杠\ 进行转义。

>> 特殊字符：^ $ \  ( ) \[ ] { }  | . ? + *

在正则表达式字面量中， 这些符号只需要 使用 反斜杠\转义一次。 比如 匹配. ，其正则表达式字面量是 \.即可。

但是在使用构造函数创建正则表达式的时候，却需要**转义两次**，因为通过 构造函数创建正则表达式需要两步:
* 解析 pattern**字符串**
* 将解析后的pattern**字符串解析为正则表达式**的pattern
碰巧，在字符串解析中， 反斜杠\也是字符串的转义字符。

因此，如果我们要创建一个匹配所有 . 符号的正则模式:
* 使用正则表达式字面量 :  /\./g
* 使用构造函数:  new RegExp("\\.","g");  第一个反斜杠用于在字符串中转义第二个反斜杠，第二个反斜杠用于在 正则表达式中 转义.符号

关于 字面量形式的创建正则表达式的方法，所有实例并不是同一个实例，就算字面量是相同的，但是每次都是创建一个新的正则表达式实例，就跟调用构造函数创建实例一样。 这是从ES5开始正式实现的。

##### 实例属性

RegExp的实例属性除了 lastIndex外,全部包含在正则表达式自身中了，因此没多大用。
* global 代表是否启用全局匹配的布尔值
* multiline 代表是否开启多行匹配的布尔值
* ignoreCase 代表是否忽略大小写的布尔值
* source pattern的字面量形式，需要注意的是，不包含flags
* lastIndex 表示下一次在目标字符串中搜索的起始位置,从0开始。
下次搜索的起始位置=本次匹配字符串的第一个字符位置+本次匹配的字符串的长度

##### 实例方法

RegExp的实例方法有两个:
* exec(目标字符串) 专门为捕获组设计
    * 如果匹配失败返回null。
    * 若匹配成功则返回的是一个包含匹配项信息的数组Array的实例。数组的每一项对应着捕获组匹配到的字符串。第0项表示完整匹配到的字符串。
    同时**该数组的长度是恒定是捕获组的数量**，并不会因为没有匹配到某个捕获组而减少长度，只是对应的项结果是undefined罢了.

        这个数组还有两个额外属性：
        * index 本次匹配的字符串在目标字符串中的位置。
        * input 目标字符串。

    需要注意的是，使用exec方法的结果与 正则表达式的 flags是有关系的。
    只有在开启全局匹配模式g后，下一次调用exec才会从上次匹配的子串之后接着匹配。否则就是从头从索引0开始匹配。

* test(目标字符串) 单纯只是验证正则表达式是否能匹配到字符串。并返回布尔值结果。

RegExp继承的Object的方法:
* toString() 返回正则表达式的字面量形式 包含flags
* toLocalString()  等同于 toString()
* valueOf() 返回正则表达式本身

##### RegExp静态属性

所谓静态属性，就是这个构造函数自身添加的属性。
RegExp的静态属性的值 全部都是根据 **上一次使用正则匹配成功**时的数据进行填充的。

* input 返回最后一次**匹配成功的**的目标字符串。
* lastMatch 返回最后一次**匹配成功**到的字符串。
* lastParen 返回最后一次**匹配成功**到的捕获组。
* leftContext 返回在最后一次**匹配成功**的目标字符串中 匹配到的字符串 左边的子串。
* rightContext 返回在最后一次**匹配成功**的目标字符串中 匹配到的字符串 右边的子串。
* $1 ~ $9 存储 上一次**匹配成功**到的字符串中 每个捕获组的匹配值。

***

### Function 类型

每个函数都是Function引用类型的实例。**函数名只是一个指向函数对象的指针**。

创建函数的方式有三种:
* 函数声明式
* 函数表达式赋值
* Function构造函数创建

这里单独说说Function构造函数创建 函数对象的方式:
>> var sum=new Function("num1","num2","return num1+num2");
在构造函数中，最后一个参数永远是真正的函数体内容，前面的参数就是创建的函数对象的参数，但不是必须的。
这种创建函数的方式是不推荐的。因为会导致解析两次：1.第一次解析该段代码。 2.第二次解析字符串。
导致性能下降。

由于函数名就只是一个指针，并且ECMAScript本身并不对参数做任何识别，参数名只是一个助记符，因此，
ECMAScript中的函数是没有重载的！

关于函数声明和函数表达式的区别，唯一区别就是 函数声明具有 函数声明提升的过程。
也就是说，在生成代码的执行上下文时，函数声明式创建的函数会被直接初始化赋值为该函数对象，而函数表达式赋值创建的函数，其函数名代表的
变量只会被初始化赋值为undefined，等到真执行到赋值语句时，才会被赋值为该函数对象。


##### 函数中的特殊属性

函数中具有两个特殊对象:
* this 指向调用者

* arguments 类数组对象，包含所有传入函数中的参数

    arguments对象除了包含 传入参数外，还有一个特殊的属性 **callee,指向函数对象自身。**
    其主要用途是为了在递归过程中去除函数名与函数对象之间的 耦合。

* caller 指向调用本函数的函数。 如果是**全局调用**，那么**caller为null**。

##### 函数中的普通属性

在**浏览器**中，函数实例**只有3个**实例属性。并且都是不可迭代的。之所以说是在浏览器中，
是因为服务器端的JavaScript不一样。

* length 表示函数期望得到的参数个数，在创建函数之时就确定了。

* name 函数对象的函数名

* prototype 指向该 函数 所代表的引用类型 的 原型对象。

##### 函数继承自Object的方法

* toString()
* toLocalString()

以上二个方法**均是返回函数的代码字符串**。

* valueOf() 返回函数对象本身。

##### 函数中的特殊方法

这三个方法本身都**存在于Function.prototype原型对象**上，函数对象实例并没有这三个实例属性。
函数对象之所以能使用这三个属性是**通过原型链访问**到的。

这三个方法之所以特殊，是因为这三个方法都能**改变 传入函数中的特殊属性 this的取值**。

* apply(一个对象，arguments对象 或 数组)  改变函数内部的this取值并调用函数。

* call(一个对象,参数逐个列出)             改变函数内部的this取值并调用函数。

* bind(一个对象)                        **创建并返回一个新的函数实例**，其this取值为传入对象。
关于bind还需要知道的一点是，创建出来的函数实例只有第一次绑定才会生效，后续的绑定是无效的。

***

### 基本包装类型

基本包装类型有三种:
* Number引用类型 用于包装 number
* Boolean引用类型 用于包装 boolean
* String引用类型 用于包装 string

就跟Java的自动装箱一样，ECMAScript中的这三种基本类型被读取的时候，也会在后台自动装箱为其对应
的包装类型实例，并可以调用方法，当数据使用完毕后，就销毁内存中的包装类型实例。

我们需要注意的一点是，Object引用类型同时也可以创建这三种包装类型的实例。
* new Object(字符串) 返回一个String对象实例
* new Object(纯数字) 返回一个Number对象实例
* new Object(布尔值) 返回一个Boolean对象实例

特别注意:**new Object(一个实例) 返回的就是 这个实例本身。**

##### Boolean包装类型

一般而言，我们根本就不推荐使用Boolean包装类型。
创建Boolean包装类型的方式有以下两种:
* new Object(布尔值)
* new Boolean(任何值或者对象) 返回的是经过 Boolean()转型后的布尔值的Boolean对象。

之所以不推荐使用的一个重大原因就是在逻辑运算时，非常容易混淆。
>>  new Boolean(false) && true ;  结果是true。 因为逻辑运算是按照基本类型boolean来的。 调用Boolean()转型。 而其规则便是 非null对象实例都是true。

同时我们还需要明白，其继承自Object的方法:

* toString() 返回 "true" 或者 "false"

* valueOf() 返回 **基本类型的 boolean 值!!!**

##### Number包装类型

Number包装类型重写了继承自Object的方法:

* toString() 返回数字的字符串表示
* valueOf() 返回 **基本类型的 number 值!!!**

另外就是一些精度相关的方法:
* toFixed(n) 返回数值 **保留n位小数部分**的字符串，四舍五入。
* toExponential(n) 返回数值 **保留n位小数部分**的字符串，但是是指数形式。
* toPrecision(n) 返回数值 **一共n位**的字符串，根据情况自动选取采取指数表示与否。

##### String包装类型

每一个String对象都具有一个实例属性length,代表着这个字符串有多少个字符的长度，需要注意的是,在ECMAScript中,一个中文也只算一个字符,因为都是unicode编码的。

其继承自Object的方法:toString，toLocalString,valueOf 均返回的是 string基本类型。

**字符**操作方法:
* charAt(index) 返回一个string基本类型，其值是index索引的字符。
* charCodeAt(index) 返回一个number基本类型,其值是index索引的字符的编码。

同时，String还提供了与数组相同的对字符的访问方法: String对象.\[index]，效果等同于 charAt方法.

**字符串**操作方法:
* concat(一个字符串) 返回一个string基本类型，其值是 两个字符串连接后的结果， 其效果等同于 + 操作符。

* slice
* substring
* substr

关于这三个方法，我们拿到一起讲， 这三个方法都是基于原本字符串 返回一个新的字符子串的方法，并且第一个参数都是指定
子串的起始字符索引位置， 不同的是， **slice和substring**的第二个参数是**结束位置索引(不包含结束位置)**, **substr**的第二个参数是**期望得到的子串的长度**。
当然，在不指定第二个参数的情况下，三种方法的功能都是相同的。

需要注意的是，以上的方法均不会改变原本的String对象，并且都是返回的是string基本类型数值。

**位置**方法:
* indexOf 从前往后搜索
* lastIndexOf 从后往前搜索
需要注意的是， 从后往前搜索并不代表是 逆序匹配的， 字符串的匹配依旧是按照 正向顺序的方式。

**删除空白符**的方法：
trim() 方法可以删除字符串中前置和后置的所有**空白符**（并不单单只是空格），并返回一个全新的基本类型string。同样不会对原对象进行任何改变。

如果原本的字符串只有空白符，那么trim方法调用后，会返回一个 空字符串""。

**大小写转换**的方法：
* toUpperCase()
* toLocaleUpperCase()
* toLowerCase()
* toLocaleLowerCase()

**正则方法**:
* match(RegExp对象)

    * 在没有开启全局匹配g下,RegExp实例的exec方法基本等同。返回的都是一个数组对象。第0项是完全匹配的内容，第i项是第i个捕获组匹配到的内容..
    同时该数组也具有特殊的input和index属性，同时匹配成功后也会反应到RegExp的静态属性上。
    * 在开启了全局匹配g下,表现就不同了。返回的依旧是一个数组对象。但是，数组的内容已经成了该**字符串中所有匹配的子串**了，不再是捕获组。
    同时该数组也**没有特殊的input和index属性**了。 但是相同的是匹配成功后也会反应到RegExp的静态属性上。

* search(RegExp对象) 返回第一次找到匹配的子串在字符串中的位置。 比较类似于indexOf，只是是按照 正则模式匹配罢了。

* replace(字符串或者正则表达式,字符串或者函数)
    需要注意的是， replace替换方法都不涉及修改原本字符串，而是返回一个被替换后的新的string基本类型。

    replace的参数组合情况有以下情况:
    * 当第一个参数为字符串时，只会替换 源字符串中的第一个匹配到的字符串。

    * 当第一个参数为正则表达式时，如果该正则表达式是全局模式，那么替换所有项，如果不是全局模式，那么也只替换第一项。

        * 当第二个参数为字符串时,字符串中可以包含特殊字符序列用于获取本次匹配到的子串以及捕获组匹配到的子串。
        但是需要注意的是，捕获组的特殊字符序列 $n 必须在原本**正则表达式中具备该捕获组时才能被解释为捕获组匹配到的子串（未匹配时解释为空字符串）**，否则就是普通的字符序列。

        * 当第二个参数为函数时,针对正则表达式中是否使用了捕获组分为两种情况.

            * 如果正则表达式中没有使用捕获组，那么函数的参数依次为:正则本次匹配到的子串，其在源字符串中的索引，**源字符串的 string基本类型副本**（因此对其修改不会影响到源字符串）。

            * 如果正则表达式中使用了捕获组，那么函数的参数依次为:正则本次匹配到的子串，捕获组1匹配到的子串，捕获组2匹配到的子串...（以此类推，有多少个捕获组就额外多多少个参数）...,其在源字符串中的索引，源字符串的 string基本类型副本。

        总之，当第二个参数为函数时，是对匹配子串的更惊喜操作(相比与使用字符串外加特殊字符序列)。


* split(字符串 或 RegExp对象, 可选的 数组最大长度)
该方法用于 将 源字符串的副本按照给定 字符串或者正则匹配到的子串，分割为多个字符子串，并放入数组中 返回。
最好还是不要在这里使用捕获组，因为各个浏览器兼容情况不同。

还需要注意的是，如果 传入的分隔符字符串是 空字符串，那么是直接返回源字符串的每一个字符组成的数组。


**String静态方法**

fromCharCode是挂载在String构造函数上的静态方法，接受任意个字符编码，并将其转化为一个string基本类型值。

其作用与 其实例字符方法的charCodeAt 相反。不过需要注意的是参数可以是任意多个。


***

### 单体内置对象

ECMAScript中的单体内置对象指的是 由 ECMAScript实现的不依赖宿主环境的对象，这些对象在ECMAScript的程序执行之前
就存在。  之前我们说的Object,Array等等的对象都是内置对象。
但是这里还要补充说明两个内置对象，Global对象和Math对象。

##### Global对象

Global对象是全局对象，一切在全局定义域定义的函数和属性都是属于这个Global对象的。
在浏览器中，Global对象是window对象实现的一部分，而window对象是属于BOM对象的。

Global对象包含了很多方法，除了之前提到过的 isNan(),isFinite()等方法，还包含了
以下的方法。

Global对象的URI编码解码方法:
* encodeURI()编码 和 decodeURI()解码
* encodeURIComponent()编码 和decodeURIComponent()解码

需要注意的是，encodeURI方法 **不会对本身属于URI的特殊字符**进行编码,比如 正斜杠/,冒号:,问号？,井号#,解码也是。
而 encodeURIComponent方法 会对**一切特殊字符进行编码(但是部分字符比如. _ - ~并不会编码)**。解码也是。

Global对象还提供了一个整个语言最强大的方法 eval(),该方法只接受一个参数一一要执行的ECMAScript代码的字符串。

##### Math对象

Math对象主要包含一些数学方面的对象和方法，比如Math.E表示数学中e的值,Math.PI表示数学中圆周率的值。

其包含的方法大致分为4类:

* 求最大值最小值的方法 :max 和 min ,  参数是任意多个数字， 返回参数中的 最大值 或 最小值。
* 舍入方法 ： ceil 向上舍入 floor 向下舍入  round 四舍五入
* 随机数方法 : random ,返回 [0,1) 区间中的随机浮点数
* 数学方法: abs 求绝对值，log 求自然对数 ，pow 求指数 ,sqrt 开方，sin 这些与正余弦 正余切相关的函数。



