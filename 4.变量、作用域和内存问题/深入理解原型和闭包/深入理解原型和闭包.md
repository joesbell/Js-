# 深入理解原型和闭包

***

### 一切引用类型都是对象，对象是属性的集合

在ECMAScript中，除了基本类型 String,Number,Boolean,Undefined,Null,其他的所有类型都是对象。

null虽然是基本类型，但是其typeof null 结果是 object。(**只是为了符合 null是空对象 这种观点，但是依旧是基本类型**)
因此 null instanceof Object 是false ，因为 毕竟 null也只是个基本类型而已。

同时，我们可以注意到，函数即是 Function 也是 Object。

***

### 函数和对象的关系

函数本身是对象，但是一切对象都是由函数创建的。

而要理解其真正关系，必须理解 prototype 原型。

***

### Prototype原型  (构造函数的)

每一个函数都是一个对象，其本身可以自带属性，而所有函数都具有的属性就是 prototype属性一一该函数的原型对象。

函数的prototype原型对象指向 一个对象。 这个 prototype原型对象 初始只有一个属性constructor指向这个函数本身。

***

### 隐式原型__proto__  (实例对象的)
每个对象实例都具有一个隐式原型__proto__，指向创建该对象实例的函数的prototype原型对象。

可以认为，每个实例对象的__proto__隐式原型对象属性都是在创建这个实例时，进行指向的。 但是 隐式原型对象本身(也就是函数的原型对象)，却是在创建函数的时候**自动创建的一个Object对象**。

所有对象实例的隐式原型最终都会指向Object的Prototype原型， 而Object.prototype(原型本身也是一个对象)的隐式原型是指向 null 的。

所有函数本身也是一个对象，而创建所有函数的构造函数就是Function函数。 因此，所有函数的隐式原型都指向 Function.prototype.(包括Object函数的隐式原型)。

甚至，连Function这个函数本身也是Function创建出来的，因此会出现 Function.__proto__===Function.prototype的情况。

因此就有如下关系:

    function Foo(){ //函数Foo
        ;
    }
    var foo=new Foo(); //foo是 Foo函数的实例对象。


    foo.__proto__===Foo.prototype; //对象实例的隐式原型是创建该对象的函数的原型。

    Foo.__proto__===Function.prototype; //同理，Foo函数本身也是Function函数的一个实例对象。
    Object.__proto__===Function.prototype; //同理，Object函数本身也是Function函数的一个实例对象。
    Function.__proto__===Function.prototype; //同理，Function函数也是由Function函数创建的一个实例对象。
    //因此可以总结:函数本身的隐式对象，都直接指向 Function.prototype 原型对象。(在这个时候，函数变得不像对象实例)


    Foo.prototype.__proto__===Object.prototype; //原型本身也是一个对象实例，而原型对象实例是由Object函数创建的。
    Function.prototype.__proto__===Object.prototype; //Function.prototype原型对象也是一个对象实例，因此其隐式原型是Object.prototype原型对象。
    Object.prototype.__proto__===null; //Object的原型对象实例也是一个对象，但是规定，其隐式原型是null。
    //因此可以总结: 一切对象(对象实例，原型对象)的隐式原型，其最终均指向 Object.prototype原型。 (在这个时候，函数就是对象实例)


***

### instanceof 操作符

instanceof 操作符 是 ECMAScript中用于判断 对象实例 与 函数 之间的 **继承关系**或者说是**原型链关系**的一个操作符。

直白点说，如果对象 a 是由 函数 B 创建出来的,那么 a instanceof B===true。 当然，这是不全面的。

instanceof操作符的标准形式是:  **对象** instanceof **函数**。

其程序化的判别方式就是，迭代地判断 对象实例a的隐式原型对象 是否全等于 函数B的prototype原型对象。
当然，这有一个最大的前提，操作符右侧必须是一个 **函数对象**！ 因为只有函数对象才实现了\[\[HasInstance]]规范属性.

因此:

    Object instanceof Function ； //true。因为 Object.__proto__===Function.prototype
    Function instanceof Function ; //true。 因为 Function.__proto__===Function.prototype
    Function instanceof Object ; //true。 因为 Function.__proto__==Function.prototype, Function.prototype.__proto__===Object.prototype
    Object instanceof Object  ;  //true。 因为 Object.__proto__是Function 。而Function.__proto__==Function.prototype, Function.prototype.__proto__===Object.prototype

还需要明白的是， instanceof操作符的左边必须是一个对象实例，如果是基本类型数据，那么就直接返回false。


在规范中:
instanceof 操作符真正的本质是 对实现内部规范属性\[\[HasInstance]]的对象进行该方法调用
a instanceof B 就是 B.\[\[HasInstance]](a) 的执行结果。
在EMCAScript中，只有 函数对象实现了\[\[HasInstance]]。所以instanceof操作符 右侧才必须是函数对象。

***

### 继承

在ECMAScript中，继承的原理就是 原型链。 或者说 ECMAScript中的继承不是通过传统的OOP的 class类的概念来实现的，而是通过 原型链。

在对象实例上没有某个属性时，会自动寻找其隐式原型__proto__上是否具有那个属性。从而实现类似于class类的继承。

因此，所有对象都具有Object类型的函数和属性，因为，所有的实例对象的隐式原型**最终都会指向Object.prototype**，而Object.prototype上就包含这些函数和属性。

同时，所有的函数不仅具有Object类型的函数和属性，还会额外具有Function类型的函数和属性，因为所有的函数都是由Function创建的实例，其隐式原型指向Function.prototype。

##### 辨析点1
需要辨析的一点， 对象实例 继承的属性是来自于 **创建该对象实例**的 **函数的prototype原型对象**，**而非函数本身。**

函数对象本身和 函数的原型对象是两个完全不同的对象!函数对象本身的隐式原型对象是Function构造函数的prototype原型对象 Function.prototype。
而函数的原型对象 的隐式原型对象 **往往是** 另一个构造函数的prototype原型对象，从而以此构造一条完整的最终指向Object.prototype对象的原型链。 **这条链条才是函数创建的 实例对象的 原型链。**

据此，我们就可以轻松的辨析，为什么一般来说，对象实例不可能拥有Function.prototype的属性和方法，虽然创建该对象的构造函数是Function构造函数的对象实例。
核心就在于:对象实例的真正的原型链是其隐式原型__proto__所指向的对象，不是 构造函数本身，而是构造函数的prototype原型对象。
构造函数本身的原型链的确是途经了Function.prototype,但是构造函数的prototype原型对象的原型链往往是不会途径Function.prototype的。

##### 辨析点2
还需要明晰的一点，当我们在说一个 foo对象实例是Foo(某个构造函数)的实例的时候，其属性继承自Foo。
但是实际上，真正准确的说法应该是，**对象foo是由构造函数Foo所创建的对象实例，其属性继承自 Foo的原型对象Foo.prototype。**

明白了这亮点点，我们就可以很轻松的理解一句话了:
Function对象具有Object的属性。
(Function是一个对象实例，其隐式原型__proto__===Function.prototype，最终指向Object.prototype，因此可以说Function对象继承了Object原型的属性)

Object对象具有Function的属性。
(Object构造函数是一个函数，因此其隐式原型对象__proto__===Function.prototype,因此可以说Object对象继承了Function原型的属性)

但是，普通的对象实例比如 new Object()，并不会继承Function的属性。
(因为对象实例继承的属性是来自于创建该对象实例的构造函数的prototype原型对象的(也就是该对象实例的__proto__隐式原型对象)。在这里，就应该是继承Object.prototype对象的属性而非Object对象的属性)

***

### 原型的灵活性

原型式继承的优点就在于灵活性，不同于普通的OOP的所使用class继承的方式，class继承的方式中，父类一旦定型了，是无法更改的。我们无法对父类随时添加属性，删除属性。

但是ECMAScript中原型式的继承却可以灵活地对"父类"进行修改。因为,父类也仅仅只是一个原型对象罢了，在ECMAScript中，只要是对象，就可以随时地进行修改操作。

我们可以通过直接的对**构造函数的prototype原型对象**添加属性，也可以利用创建出来的**对象实例的隐式对象**来添加属性，其效果都是相同的。因为指向的原型对象都是同一个对象。

当我们不再需要对象继承这个属性的时候，我们唯一能做的就是使用delete删除在实例所继承的原型对象上的该属性(而非在对象实例上删除,对于继承属性这是无效的)，但是这会影响到**所有继承该原型对象的实例**。

***

### 执行上下文环境 ： 静态性 和 动态性 结合(个人理解)

总览：

所谓执行上下文环境，就是在**某段(更深入的理解可以是某句)代码真正执行之前，所做的准备工作(获取执行环境，比如变量值等操作)。**

普通的理解，执行上下文是静态的，发生在某个代码段执行之前。

但是更深入的理解，执行上下文也是动态的，因为代码段的执行上下文也是在不停更新的，或者说**代码执行环境是随着代码的执行而不断更新的。**

执行上下文的**静态性**表现在:在**未执行任何代码段之前**，就已经做好了**最初的变量声明和初始化赋值**工作。

执行上下文的**动态性**表现在：伴随着**每一句代码执行**，变量的值都会随着代码执行而改变，而这又会**随之更新**到执行上下文中，以便**下一条语句**执行。

***
逐步深入：

比如说:

    第一段代码:
    console.log(a);  // 输出 undefined
    var a=10;
    --------------------------------------
    第二段代码:
    console.log(a);  // 而这会报错  a is not defined

从执行顺序来看，第一段代码在执行第一句时，其实a也是没有定义的，但是！却不报错，这说明，在这段代码真正执行之前，引擎已经做了一些准备工作了。
正是这些准备工作，让引擎知道，某个变量并不是不存在，而仅仅是展示undefined(初始化赋值)罢了。而这些准备工作，就可以通称为 执行上下文环境。

执行上下文环境的内容包含了在当前环境下，所有**变量符号**的存在性检测(声明)和以及将**变量**进行预设值。

现在我们再重新解释一次，执行上下文，是指代码段在未执行时，引擎进行的一些准备工作，通过这些准备工作,告诉了后续将要执行的代码段:

* 哪些**变量符号**是存在的。
* 哪些**变量是有预设值**的。

然后,这些信息会在真正执行代码时，进行使用,**并随代码执行而更新到执行上下文环境中**:
* 对于不存在的变量符号(也就是**未声明的**),代码执行会抛出异常
* 对于变量,进行变量**值的更新(在预设值的基础上)或者读取**操作

而实际上，代码段是分为三种情况的:
* 全局代码段(主函数)
* 普通函数体
* eval代码段

首先在进入主函数之前，会扫描主函数并做好准备工作，当代码执行到函数调用时，又会为之生成一个全新的上下文环境，
当执行到eval语句时，又会为eval语句生成一个上下文环境。其余时候，执行代码本身只是读取变量值和变量赋值操作罢了。

其中也会有些特别的操作:eval语句中以及普通函数体中，可以进行**新的全局变量声明**，并影响到全局代码段的执行上下文环境。

这里还得特别说明一下:函数表达式和函数声明的区别一一函数声明享受着 **函数声明提升** 这个效果。

    var fn=function(){
        ...
        函数体
    };  //这是函数表达式赋值。
    对于该段代码的执行上下文来讲，是不会将 fn等同于这个函数表达式的。 也就是说，初始赋值 fn 依旧是undefined。
    只有当代码真正执行时，才会将函数表达式赋值给fn。

    等同于:
    var fn; //变量声明
    fn=function(){
        ...
        函数体
    }; //fn赋值


    function fn(){
        ...
        函数体
    }   //这是函数声明
    对于函数声明来讲，无论放在 该！！!(三种代码段形式) 代码块的任何地方，都享受函数声明提升：在解析阶段会将放在该代码段
    顶端并将其读取到。
    因此对于该段代码的执行上下文来讲， fn就声明并初始化赋值为这个函数了。

总结一下:

* 对于全局代码段,执行上下文为

|内容   | 初始化值  |
|------|----------|
|**本身**的变量声明| undefined|
| this | 当前代码段的拥有者一一window|
|**本身**的函数表达式| undefined|
|**本身**的函数声明| 该函数本身|

* 对于eval表达式，执行上下文为

|内容   | 初始化值  |
|------|----------|
|**本身**的变量声明| undefined|
| this | eval表达式**所在的代码段的this取值**|
|**本身**的函数表达式| undefined|
|**本身**的函数声明| 该函数本身|
|外部一切变量| eval表达式执行到**所在代码行时**的**代码段动态执行上下文**|

也就是说，eval表达式的执行上下文中不仅拥有 对eval代码段的变量声明以及初始化赋值，
还具有**当代码执行到eval语句时**的**当前代码段的动态执行上下文信息**。

(**执行副作用**)
同时，eval表达式**内部的函数声明以及变量声明以及变量值**，也会在eval语句执行完毕后**更新到当前代码段的动态执行上下文中**。

* 对于普通函数体，执行上下文为

|内容   | 初始化值  |
|------|----------|
|**本身**的变量声明| undefined|
| this | 当前代码段的**调用者**|
|**本身**的函数表达式| undefined|
|**本身**的函数声明| 该函数本身|
|参数变量| 传入参数值|
|arguments对象| 传入的参数对象|
| 自由变量的**取值域**| 根据**创建时的**作用域链找到取值域所在并赋值|
|自由变量本身| 根据**函数调用时**取值域所在代码段的动态执行上下文获取值并赋值|
|全局变量声明(不使用var声明的变量)|全局变量当前值|

每次函数调用，都会产生新的执行上下文。参数变量，arguments对象，this，全局变量是会发生改变的。
其 **自由变量取值域**也是是不会改变的，但是**自由变量本身的取值是会发生改变的**。

(**执行副作用**)
和eval表达式一样，当函数执行完毕后，自由变量的改变也会更新到 **该自由变量所在的代码段**的**动态执行上下文中**。
其声明的全局变量，会更新到全局代码段的**动态执行上下文**当中。

***

### this 在函数体中的取值。

首先先明确一点，函数中this的取值是在**调用时决定的**，是个**运行时概念**，而**不是在创建函数时决定**。

总的来说，函数的调用有两种情况:

* 作为构造函数来创建对象: new 函数名()，此时函数体内的this是指向的这个被创建出来的对象。

* 作为普通函数被**某个对象**所调用：此时，函数体内的this是指向 函数的调用者对象。

而作为普通函数时，其实可以更为细致地分为以下三种情况:

* **直接调用函数**，没有显式地说明调用者: 函数名() ,此时函数的调用者对象为全局对象，this取值就是window

* **对象调用函数**,显式地说明了调用者: obj.函数名(),此时函数的调用者对象为obj,this取值就是obj

* 使用函数**自带的apply,call方法调用函数**，显式地指明了调用者:函数名.call(obj,参数),此时函数的调用者对象为obj，this的取值就是obj.

这就是判别this取何值的规则。

***

### 作用域

所谓作用域，就是**变量存在的环境**。我们说一个变量存在，就是说在这个作用域内，可以找到这个变量。声明变量，就是在这个作用域中添加变量。

在ECMAScript中，作用域只能**由函数进行创建**。由函数创建的意思是,**函数体内的作用域**和**函数体外的作用域**是不同的作用域。

因此，在函数体内外，变量存在的环境不同，可以起到良好的**隔离变量**的作用。

所以我们可以说，ECMAScript中是没有块级作用域的，因为 { 块级代码段 } 并不是一个函数体，因此无法创建作用域。

正如同函数体内部是可以声明函数一样，作用域也可以存在这种嵌套关系。
即作用域内部可以创建新的独立的作用域。
外部的作用域无法访问内部的作用域，而内部的作用域可以访问外部的作用域。

这种嵌套关系就形成了一条作用域链。

另外需要注意的一点是，ECMAScript自带一个作用域，就是全局作用域。

全局作用域是任何作用域的最终父级作用域，位于作用域链的最尾端。因此在一切作用域中，都可以访问到全局作用域的内容。


***

### 自由变量以及作用域链

所谓自由变量，就是在**当前作用域下没有声明**，但是却使用了这个变量，而这个变量其实是**其父级作用域拥有的**。
这种变量就叫做自由变量。

自由变量又和作用域链是紧密连接在一起的:
* 其**取值作用域**：自由变量在某个**函数作用域创建时**时决定，而**不是根据调用时的当前作用域**决定。
* 其**取值**:根据**取值作用域所在的代码段的动态执行上下文**决定，而不是创建时的赋值决定。

其规则是，沿着**函数创建时的作用域**的作用域链依次向外部找，只要找到声明该自由变量的作用域便停止，并在以后
该函数生成的执行上下文中，初始化赋值自由变量的取值作用域为该作用域。至于具体取值，则是由该作用域所在的代码段
的动态执行上下文决定的。

***

### 执行上下文栈

我们这里对执行上下文栈只讲最基本的情况，因为非基本情况的执行上下文栈就是 闭包了。

执行上下文栈的最基本的情况就是:每当执行函数时，会**重新生成**一个执行上下文栈，当函数**执行完毕**后，该执行上下文栈**被销毁**。

这是基本的执行上下文栈的执行流程。


***

### 闭包

什么是闭包？

闭包就是 函数体中使用了**自由变量**.

在ECMAScript中，由于 **函数可以创建执行上下文** 以及 **函数可以创建新的作用域**,使得闭包变得有趣了。

        function fn(x){
            var max=x;
            return function bar(y){
                if(y>max)
                {
                    console.log("超出");
                }else {
                    console.log("没有超出");
                }
            }
        }

        var mybar=fn(10);
        var max=100;
        mybar(15); //打印 超出

        var mybar2=fn(16);
        mybar2(15); //打印 没有超出

这就是一段非常常见的闭包的运用。

可以看到，我们两次调用fn函数返回两个bar函数，每个bar函数的max数值都是相互独立的，
同时也可以看到，bar中max的的取值并不是在全局作用域中而是fn的作用域中(参看自由变量取值域的确定)。（**这同时也是闭包的优点**）

之前谈过 执行上下文栈 的执行流程，我们当时提到，普通的执行上下文栈执行流程中，函数执行完毕后，其执行上下文栈就会被销毁。
当时我们也说了，那只是简单的执行上下文栈执行流程，一旦其执行上下文栈不被销毁，那么就是闭包的情况了。

这里我们可以先来看看这个闭包是否会如同普通的函数执行一样，执行完毕后就进行销毁.

反证:
如果当fn函数执行完毕后，fn函数创建的执行上下文被销毁了,那么，当我们在调用mybar的时候，mybar会创建一个新的执行上下文栈，
这个栈中有参数，有自身的变量，有this取值，还有更为重要的一点：自由变量。
自由变量的取值域是在**函数创建**的时候就被决定了的，并依靠**作用域链**进行寻找，在这里就是fn函数的作用域；
自由变量的取值是在**该作用域所在的代码段的执行上下文中**获取的，在这里，也就是fn函数创建的执行上下文中获取值，
如果fn函数创建的执行上下文栈被销毁了，那么自由变量max就无法**实时地取值**，那还如何执行呢？
事实证明，mybar执行的很顺利.因此说明调用fn函数创建的执行上下文栈并没有在执行完毕后被销毁.

以上就是 闭包 在ECMAScript中的运行流程了。下面我们再来总结下 闭包的本质。

ECMAScript中闭包的本质可以说是依赖于前面提到过的两个特质:
* **函数每次执行都会创建执行上下文** （核心诱因）

* **当且仅当函数可以创建新的作用域**  (自由变量 存在的原因，如果函数不能创建作用域，或者说作用域只有一个，那么何谈自由变量?)

我们可以通过观察发现，闭包出现的情况，无一例外都是出现了一个重要的主角:**函数**,不管是**作为返回值的函数**，还是**作为参数的函数**。
究其本质,就是源于ECMAScript中函数具有以上两个特质。

当我们传入或者获取的值是一个函数的时候，该函数在使用(调用)的时候，必定会创建一个全新的执行上下文栈，这个执行上下文栈**势必要进行初始化**，
在初始化过程中，一旦遭遇了闭包的另一个主角一一**自由变量**,就会自然而然的需要两个关键信息:**自由变量的取值域**和**自由变量的取值**。
自然变量的取值域在**函数执行上下文**规定中明确指出:在创建该函数的地方，沿着**作用域链**自内向外寻找该自由变量所在的作用域。
自由变量的取值也在**函数执行上下文**规定中明确指出:在**该作用域所在的代码段的执行上下文中**获取该自由变量的取值。
因此，被闭包引用到的代码段的执行上下文是不能被销毁的:
其根本原因在于，**函数调用必须创建并初始化执行上下文栈**，而**自由变量的取值**必须**依赖于外部的执行上下文栈**。

因此在闭包的情况下，执行上下文栈中的执行上下文是不会被销毁的。只有当闭包不再使用时,执行上下文栈中涉及该闭包的执行上下文才会被销毁。

另外明确的一点是:并不是说闭包函数被调用时创建的执行上下文不被销毁，而是说，**闭包函数所引用的自由变量所在的代码段的执行上下文**是不被销毁的。

以上,就是闭包的完整内容。可以看到在闭包的运行流程，本质上就是之前特质的相互作用的结果:

* 执行上下文的初始化创建是核心诱因

* 作用域是自由变量存在的原因

* 作用域链又是寻找自由变量取值域的基础

* 执行上下文栈对执行上下文的管理又是程序正确运行的基础


可以看到ECMAScript中的闭包赖以生存的环境就是执行上下文了。
由于**执行上下文的动态性**又引发一个副作用:即**闭包函数中的自由变量在真正调用的时候只能获取该自由变量的当前值**。

我们用代码说话:

    var array=[];
    var i;
    for(i=0;i<10;i++){
        array[i]=function(){
            return i; //函数内部引用了自由变量i
        }
    }

    var j;
    for(j=0;j<10;j++){
        console.log(array[j]()); //期望打印 0~9  ,实际打印的都是10
    }

这段代码，在我们期望的执行结果中，应该最终是输出 0到9的，但是实际结果是 全部输出10.
其根本原因就在于，在**函数体内部引用了外部作用域的自由变量**，**构成了闭包**，
因此在真正**执行该闭包函数**时，在闭包函数的执行上下文栈创建并初始化时，**自由变量的取值是实时地出外部代码段的执行上下文中获取的**，
而此时外部代码的执行上下文中的自由变量i此时已经是10了。所以最终出现了这种出乎我们意料的结果。

想要获得我们预料的结果有两种方式可以修改。
* 直接使用值，这样就不涉及闭包了
* 再创建一个函数，并在其作用域内保存每一个值，再将这个值作为自由变量交给闭包函数。

于是就有了：

    var array=[];
    var i;
    for(i=0;i<10;i++){
        array[i]=i; //直接使用值。
    }

    var j;
    for(j=0;j<10;j++){
        console.log(array[j]);
    }

这样看上去不怎么"函数"，因此我们可以选择:

    var array=[];
    var i;
    for(i=0;i<10;i++){

        array[i]=function(x){  //使用一个立即执行函数。
            return x;
        }(i);
    }

    var j;
    for(j=0;j<10;j++){
        console.log(array[j]);
    }

以上两种方式都是本质是直接使用了值， 我们还可以使用第二种方式，再创建一个函数并通过**闭包函数引用该执行上下文中的自由变量来保存每个值**

    var array=[];
    var i;
    for(i=0;i<10;i++){

        array[i]=function(x){
            var value=x;
            return function(){
                return value;  //引用外部函数的自由变量value。
            }
        }(i);//由于该函数每次传值执行都会创建一个执行上下文，因此，x参数的值不同，
             //而每个执行上下文中的变量value都会被内部的闭包函数所引用，因此其执行上下文不会被销毁。
             //虽然执行完毕了，但最终执行上下文栈中会存在10个该函数的执行上下文。
    }

    for(i=0;i<10;i++){
        console.log(array[i]());
    }

至此，关于闭包的一切都讲完了。