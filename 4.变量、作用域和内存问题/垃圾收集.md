# 垃圾收集

JavaScript具有GC机制。

虽然对于JavaScript来说，大多数情况，看似进行内存的清理回收是非常简单的，因为JavaScript只
需要维护一个执行上下文栈的，而只有函数的调用才会创建新的执行上下文，并且伴随着执行完毕就被销毁。

但是，这只是一般情况，还有许多特别的情况，比如闭包，此时受引用的自由变量所在的代码段的执行上下文就不会被销毁。

因此，我们的GC机制必须追踪到底有哪些变量会被使用，哪些变量是已经没有用的了。
对此，大体上JavaScript的GC具有两种方式:

* **标记清除**(目前广泛采用)

* **引用计数**(由于循环引用的问题基本不会使用了)

而引用计数的循环引用问题，并不会因为转而使用标记清除就解决了。因为低版本的IE浏览器中的部分对象并不是由JavaScript写的。
而是使用C++写的COM对象，而这些COM对象的垃圾收集回收机制采用的就是引用计数。

因此，一旦我们书写的原生JavaScript对象与IE浏览器的COM对象发生了循环引用的情况，那么由于IE的COM对象不会
被垃圾回收(因为采用的是引用计数)，因此也会间接导致我们的原生JavaScript对象也不会被回收。
为了避免这种情况，我们应该在使用完毕这些对象后手动进行解除引用，其解除引用的方式就是给变量赋值为null。

当然，IE9已经修复了该问题，已经将原本的COM对象改为原生JavaScript对象实现了。但是我们也应该保持这种好习惯：
一旦对象没有使用后，手动赋值为null。

当然解除引用并不代表会被立刻垃圾回收，解除引用的真正作用是让该数据脱离执行环境,以便垃圾回收机制在**下次回收时**进行回收。