# 使用Canvas绘图

HTMLCanvasElement类型是HTML5新增的类型，主要用于绘制图形。

canvas元素具有以下属性用于设置画布区域:
* height 绘制(画布)区域的高度
* width 绘制(画布)区域的宽度

要想绘图光获取画布是不行的，还必须获取到画布的绘图上下文引用。 

canvas元素提供了**getContext(type)方法**用于获取画布的绘图上下文。比如传入 "2d" (**必须是小写的d**) 参数就能获取到 2D的绘图上下文CanvasRenderingContext2D类型对象。

利用这个绘图上下文的方法和属性我们就能完成图形的绘制。

***

### 2D上下文

2D上下文可以绘制简单的2D图形，比如矩形，弧线，路径。

2D上下文的原点坐标默认是 canvas元素的左上角。因此， canvas元素的height属性就是 y坐标的最大值，而width属性就是 x坐标的最大值。这些坐标是以像素点为单位的。

***

#### 填充和描边

2D绘图的基本操作有两个:
* 填充 使用指定样式填充图形
* 描边 使用指定样式只绘制图形的边。

对应的，2D上下文提供了两个属性用于控制填充或者描边的样式:
* fillStyle  用于设置填充样式
* strokeStyle 用于设置描边样式

这些样式可以是**CSS中任意格式**(颜色名，16进制，rgb,rgba等格式)的颜色值，也可以是渐变对象或者是模式对象。

>> rgba(255,12,12,0.5) ,rgb(255,1,1), red ,#f0f0f0 等格式的颜色字符串均是可以使用的填充或者描边样式的格式。

***

#### 绘制矩形

矩形是唯一一种可以在2D上下文中**直接绘制**的图形。

2D上下文中绘制矩形有以下方法：
* fillRect(x,y,width,height) 绘制一个矩形并填充， 矩形的左上角坐标为(x,y) 
* strokeRect(x,y,width,height) 绘制一个矩形并描边， 矩形的左上角坐标为(x,y)
* clearRect(x,y,width,height) 清除这个矩形区域的区域。效果类似于在这个位置绘制一个背景色样式的填充矩形。

通过设置2D上下文的lineWidth可以控制绘制的线条的宽度。 **矩形实际占用的空间**等于我们设置的**width+lineWidth**。

而设置lineJoin可以设置线段相交的方式，有 "miter" "bevel" "round" 属性可供选择，分别代表不同的相交方式，如果需要圆头相交我们可以设置为 "round".

***

#### 绘制路径

图形是由边，也就是路径组成的。通过绘制路径，我们可以自由地绘制出我们想要的图形。

绘制路径和绘制矩形不同，绘制一条路径需要经过以下步骤:
* 创建路径起始点。我们可以使用**beginPath()函数**创建一条**新的路径**。
* 使用画图命令描述路径。 比如 **lineTo()画线**  **arc()画弧线**。
* 封闭路径(**非必须**)。 使用**closePath()函数**封闭。 对于已经首尾相连的路径，无需封闭，因为已经自动封闭了。
* 真正的开始绘制。 使用fill()函数填充路径包含的内容区域 或者 stroke()描边路径。 当**使用fill()填充时,会自动封闭路径**。

以上就是绘制一条路径的步骤。除了封闭路径不是必须的以外，其他都是必须的。

绘制路径的2D上下文具有以下方法:
* moveTo(x,y) 将笔触(**绘制的起点**)设置为(x,y)坐标.
* lineTo(x,y) 将当前笔触所在的坐标和(x,y)坐标连接。
* arc(x,y,r,startAngle,endAngle,counterclockwise) 以(x,y)为圆心,r为半径,画角度从startAngle到endAngle的圆弧，如果**counterclockwise为true，那么按照逆时针算**，否则是顺时针。
* bezierCurveTo(c1x,c1y,c2x,c2y,x,y) 以上一点为起点,(x,y)为终点，(c1x,c1y)为控制点1，(c2x,c2y)为控制点2，绘制三次贝塞尔曲线。
* quadraticCurveTo(c1x,c1y,x,y) 以上一点为起点,(x,y)为终点，(c1x,c1y)为控制点，绘制二次贝塞尔曲线。
* rect(x,y,width,height) 绘制一个(x,y)为其左上角,width是宽度，height是高度的矩形路径。
* isPointInPath(x,y) 判断 (x,y)点是否位于2D上下文中的某个路径上 

利用这些方法，我们可以绘制非常复杂的图形和路径。

***

#### Path2D

在绘制路径的时候，使用Path2D对象可以非常方便的复用路径的绘制方式。

Path2D类型拥有和CanvasRenderingContext2D 2D上下文类型**一样的绘图API**。 同时还额外添加了一些便于复用路径的API，比如addPath(path)可以将另外一个路径放到当前路径中来。

创建Path2D对象的方式也非常简单，利用其构造函数即可 new Path2D() 。 使用时，Path2D对象不能自己真正的绘制出自己，必须将Path2D对象作为参数传给 2D上下文的stroke或者fill方法才能真正的描边或者填充路径。
换言之，**Path2D对象只是描述路径如何绘制罢了**。 

同时还需要注意的是，Path2D对象没有beginPath()方法，因为其自身在创建的时候，就默认开始了路径的绘制描述了。

***

#### 绘制文本

绘制文本的方式有两种:
* fillText(text,x,y,maxLength)  填充文本
* strokeText(text,x,y,maxLength) 描边文本

在调用之后不需要再调用 2D上下文的fill() stroke() 就可以依靠strokeStyle或者fillStyle进行真正的绘制了。

文本的相关属性是在 2D上下文中设置的:
* font 就跟CSS的font属性一样的格式。
* textAlign 设置文本的对齐方式

    * "start"("right") 文本绘制的**起点位置**在传入的(x,y)点。
    * "middle" 文本绘制的**中点位置**在传入的(x,y)点。
    * "end"("left") 文本绘制的**终点位置**在传入的(x,y)点。
    
* textBaseline 设置文本的基线位置
    
    * "top" 基线位置位于文本块顶部。 此时，文本的实际绘制位置要低于我们传入的 (x,y)坐标点
    * "hanging" 基线位置位于文本块的悬挂线位置。 此时，文本的实际绘制位置要低于我们传入的 (x,y)坐标点。但是比top时，绘制位置稍高。
    * "middle" 基线位置位于文本框中部。 此时，文本的实际绘制的垂直方向的中点等于(x,y)坐标点
    * "alphabetic" 基线为**标准的字母基线**，这是基线位置的默认值。 此时，文本的实际绘制位置要高于我们传入的 (x,y)坐标点
    * "ideographic" 基线为 **表意文字基线**。此时，文本的实际绘制位置要高于我们传入的 (x,y)坐标点
    * "bottom" 基线位置位于文本块底部。 此时，文本的实际绘制位置要高于我们传入的 (x,y)坐标点

2D上下文还提供了一个**measureText(text)方法**用来测量绘制文本的宽度。这个方法返回一个TextMetrics对象，该对象有个width属性，表示在2D上下文的
font条件下，绘制text文本需要多少像素。 

***

#### 变换

说到变化首先就得说 2D上下文的以下两个方法:
* save() 保存当前2D上下文的**绘画选项状态**,(**而不是画布的内容**),将其推入2D上下文状态栈中。
* restore() 从当前2D上下文**栈顶弹出**绘画选项用以覆盖当前2D上下文绘画选项。

所谓绘画选项状态,是指:
* 当前应用的变换选项(移动,缩放,旋转,缩放等)
* strokeStyle,fillStyle等关于填充和描边的样式,lineCap等关于线段的样式,ShadowerColor等关于阴影的样式,font等关于文字字体的样式。
* 当前的裁剪路径

而**不是保存某一时刻画布中绘制的内容!**,通过保存绘画选项状态，在变换时可以很方便的保存当前配置或者回到之前配置状态。

第一种变换方式是**移动**,该方法为translate(x,y)用于将**当前原点位置**向左移动x,向下移动y。 也就是说，移动的基点是之前的原点位置而不是(0,0),

因此,假如我们想要移动原点到(200,200)位置，如果当前原点位置已经是(100,100)了,那么我们只需要 translate(100,100)即可。

第二种变换方式是**旋转**,该方法为rotate(angle)用于将x轴沿着**顺时针方向**旋转angle弧度。这里需要注意的是，**旋转的中心始终是原点**。

第三种变换方式是**缩放**,该方法为scale(xScale,yScale)用于将画布的X轴和Y轴垂直方向按照参数数字进行缩放。 

需要注意的是，缩放是在**当前基础上**的。 也就是说，如果连续调用两次scale(0.5,0.5),那么效果其实等价于调用一次scale(0.25,0.25).

另外，进行缩放的其实不是图像本身，而是 **坐标系中的单位长度1 和 1像素间 的比例**。 

正常情况下， 坐标系中的单位长度1对应着 1像素在屏幕中占据的长度。而进行缩放后， **坐标系的单位长度/1像素的长度 = scale值**。 因此，当scale>1时， 坐标系中的单位长度等于 scale个像素的长度，表现为放大了。反之，则是缩小了。

原本移动原点100个坐标系单位长度，如果缩放为2倍。那么实际上，原点只需要移动50个坐标系单位长度，那么在屏幕上显示的效果(也就是像素)就跟原本没缩放时移动100个坐标系单位长度的效果是一致的。

第四种变换方式是**变换矩阵**,提供了两种方法，transform和setTransform，参数都相同:
* m11 
* m12
* m21 
* m22
* dx
* dy

对应着矩阵

    | m11 m21  0 |
    | m21 m22  0 |
    | dx  dy   1 |
    
不同的是，transform是在当前变换矩阵的基础上进行变换，而setTransform是直接将当前变换矩阵设置为我们传入的矩阵参数所生成的变换矩阵。

而resetTransform就是将当前的矩阵重置为单元矩阵

    | 1 0 0 |
    | 0 1 0 |
    | 0 0 1 |
    
等价于 setTransform(1,0,0,1,0,0)

使用变换矩阵的任何操作都可以还原成 前三种变化方式，即移动和缩放以及旋转，只不过更加方便罢了。

***

#### 绘制图像

在2D上下文中绘制图像，首先是要获取到图片源，2D上下文的**drawImage**方法支持以下类型的图片源:
* HTMLCanvasElement 将一个canvas元素作为图片源。
* HTMLImageElement  将一个image元素作为图片源。
* ImageBitmap       将一个位图作为图片源。
* HTMLVideoElement  将一个video元素作为图片源,此时图片为视频的截图。

在使用位图作为图片源时，会用到 windows对象上的**createImageBitmap()方法**,该方法**返回一个Promise**，resolve为生成的**ImageBitmap类型的位图对象**,该方法的参数按顺序排列有以下几个:
* src 图片来源,种类更多，可以是HTMLImageElement,HTMLVideoElement,HTMLCanvasElement,SVG,Blob,ImageData等等。 
* x   截取的位图的起始x坐标
* y   截取的位图的起始x坐标
* width 截取的位图的宽度
* height 截取的位图的高度
* options 一个用于设置截取方式的对象。可选参数。

而绘制图像的方法 drawImage 支持以下三种传参:
* drawImage(imgSrc,x,y) 最简单的绘制，在 (x,y)坐标绘制imgSrc图片
* drawImage(imgSrc,x,y,width,height) 缩放的绘制，在 (x,y)坐标绘制宽度为width,高度为height的imgSrc图片
* drawImage(imgSrc,sx,sy,swidth,sheight,dx,dy,dwidth,dheight) 裁剪的绘制，将图片源中 (sx,sy)坐标开始的高度为sheight，宽度为swidth的图像裁剪下来绘制到 (dx,dy)坐标开始的高度为dheigth,宽度为dwidth的区域。

***

#### 绘制阴影

控制阴影的效果的属性在2D上下文上，有以下4种:
* shadowOffsetX 控制阴影在x轴上的宽度， 默认值为0且值可正可负,当为正时,表示阴影在x轴正方向绘制(向右)。
* shadowOffsetY 控制阴影在y轴上的高度， 默认值为0且值可正可负,当为正时,表示阴影在y轴正方向绘制(向下)。
* shadowColor   控制阴影的颜色
* shadowBlur    控制阴影的模糊程度，默认为0,值越大表示越模糊。

需要注意的是,虽然阴影本身并不受变换矩阵的影响，但是阴影的位置是相对于原本图形或者文字的位置来定的。

当图形或者文字受变换矩形的影响发生旋转或者位移时，阴影会伴随图形或者文字的位置变化而发生改变。

***

#### 渐变

渐变是一种**CanvasGradient**类型的对象,用来描述**颜色的渐变过程**,可以用于2D上下文的fillStyle或者strokeStyle。

渐变分为两种：
* createLinearGradient(startX,startY,endX,endY) 创建的一个从(startX,startY)坐标到(endX,endY)坐标的**线性渐变**。
* createRadialGradient(x1, y1, r1, x2, y2, r2) 创建一个以(x1,y1)为圆点,r1为半径的圆到一个以(x2,y2)为圆点,r2为半径的圆的**放射渐变**。

所谓线性渐变,代表**一个方向(向量)上**发生渐变,而**不仅仅**是我们创建的渐变范围中发生渐变。当然，在创建的渐变范围里，渐变是百分百发生的，并且是**从开始到结束都完整经历**。

线性渐变中会用到CanvasGradient渐变类型的**addColorStop(position,color)方法**,该方法用于**指定渐变如何发生**一一在渐变过程中不同色标位置position的颜色color之间会出现渐变效果。
在渐变中，色标可以有多个，甚至**色标可以重合**,但是重合的**色标的先后顺序不能交换**一一一旦交换就表示了不同的颜色之间的渐变。

本质上可以将线性渐变想象成一只**宽度无限长**的画刷, 起点坐标和终点坐标本质上是指明了**画刷的方向**,同时也指明了**画刷的起点和终点**。
而addColorStop的色标设置其实是指明这只画刷在**画到某个位置的过程中必须逐渐变色，直至到达该位置时变为设置的颜色**。

而放射渐变，则是 由一个圆向另一个圆进行渐变。 一般而言我们主要使用的是**包含关系的同心圆**。 相离关系的放射渐变是很少使用的。

当我们需要营造3D的效果的时候，可以使用包含关系的非同心圆的放射渐变。

***

#### 模式

2D上下文具有方法createPattern()用来创建模式CanvasPattern对象,该方法具有两个参数:
* 图片源 可以使用绝大多数种类的图片源，和**创建位图ImageBitmap对象**所能使用的图片源一样。 但是需要注意的是，这里必须对于需要加载的图片源，必须**确保图片已经完全加载完毕**才能创建模式。
* 模式行为 包含4种行为  "repeat" "repeat-x" repeat-y" "no-repeat" 

模式主要是用于绘制重复的图形，和渐变相似，使用模式的方式是将其赋值给**2D上下文的fillStyle**。

***

#### 图像数据的像素操作

对图形数据进行像素级操作的方式是通过操作ImageData类型的图像数据对象来进行的。

**ImageData图像数据类型**具有以下属性:
* width  图像的宽度
* height 图像的高度
* data   图像的像素rgba信息的数组，类型是 **Uint8ClampedArray**

在图像数据类型中，每个像素点的rgba信息是分别以**8位**的数据格式存储在紧挨着的data数组内的.因此取值范围是0-255.

对于图像数据类型的data属性，其数组的长度是 width * height * 4 . 每个像素点的数据顺序是 **red green blue alpha** .

要获取图像中 x 列 y 行的像素点的rgba信息，就是在data数组中获取从 **( y * width + x ) * 4 到 ( y * width + x ) * 4 + 3** 的索引的数据的信息。

得到ImageData对象的方式有两种,均是2D上下文对象提供的:
* **getImageData(x,y,width,height)** 获取画布中以(x,y)坐标为左上角顶点的高为height,宽为width的矩形区域的图像数据对象。
* **createImageData(width,height)** 创建一个宽度为width,高度为height的,**像素信息数据均为预设值**(预设值为透明黑)的 图像数据对象。

而在2D上下文中写入 图像数据的方法是**putImageData(imgData,x,y)**，这个方法将 图像数据写入到画布中的以(x,y)为左上角顶点的，宽度为imgData.width,高度为imgData.height的矩形处。

***

这里再次说明一点: **作为对象的canvas对象的 height和width属性 以及 作为DOM元素的canvas元素的style属性中的height和width属性是不同含义的属性！**

作为对象的画布自身的width和height属性表示的是画布内部的**坐标系的x y 轴 最大值**。 这个值是不带单位的**纯数字**。

而作为DOM元素的画布style中的width和height属性表示的是画布这个DOM元素的宽度和高度,也就是说是**画布元素占据的像素区域的大小**。 这个值需要带上单位"px"或其他单位。

如果将画布的像素区域大小变大而坐标系大小不变，那么就会导致图像被放大了。因为这意味着**一个坐标单位长度被绘制成了更大的像素单位长度**了。

***

#### 合成

合成是指 **将要绘制**的新图形和原本的已经绘制好的图形的组合。

合成主要依赖于 2D上下文的 **globalCompositionOperation**属性，通过为该属性设置不同的值，可以设置不同的合成方式。 具体参看 合成.html 的例子。

***

#### 裁剪

裁剪是设置一片区域，之后绘制的新图形，只有在这块区域内部的内容才会被绘制出来。

2D上下文提供了 **clip()方法**来将一条**路径**包围的区域设置为剪裁区域。

需要注意的是，这里着重强调是路径， 也就是说，只有使用:
* lineTo 手动绘制直线边连接路径
* arc 绘制圆路径 
* bezierCurveTo 绘制三次贝塞尔曲线路径
* quadraticCurveTo 绘制二次贝塞尔曲线路径
* rect 绘制矩形路径

这些方法**绘制的路径才能被设置为剪裁区域**。 而使用诸如 strokeRect fillRect 等方法是不能设置剪裁区域的。

***

#### 图形内部区域的定义一一 非零环绕规则和奇偶规则

关于点是否在图形内部区域，相离的图形自然可以直接判断出来，但是对于**相交的图形**而言，却具有两种不同的规则来判断点是否处于图形内部：
* 非零环绕规则 **"nonzero"** canvas的默认值
* 奇偶规则 **"evenodd"**

这两种规则的相同之处都在于:  判断点P是否属于图形内部，均需要**从点P做任意一条射线射向图形外部**。

而对于非零环绕规则来说， 路径是具有方向的，分为顺时针和逆时针方向，如果这条射线穿过的 **逆时针边等于顺时针边**，那么这一点就**不属于**图形内部。反之，则属于图形内部。

而对于奇偶规则来说，只用管穿过的路径的条数即可，如果穿过**偶数条**边，那么这一点**不属于**图形内部。反之，奇数条则属于图形内部。

这两种规则可以作为参数 传递给**clip() 裁剪方法  和 fill() 填充方法**，用以辅助2D上下文判断如何设置裁剪区域以及如何填充图形。