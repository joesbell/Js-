# BOM

BOM叫做浏览器对象模型(Browser Object Model).  BOM的本质是在浏览器端提供了接口供给ECMAScript使用，使得我们的JS代码能如同操作普通对象一样，控制浏览器的行为。

浏览器的**BOM核心对象是window**一一window不仅仅是作为全局对象的实现，还是BOM核心对象的实现。 

**作为BOM的window对象，代表的是浏览器的一个实例。**

BOM主要有以下5个最主要的对象：

* 处于顶层的Window对象:表示浏览器窗口实例
* Navigator对象:表示浏览器本身的信息
* Screen对象:表示屏幕信息
* History对象:表示浏览历史信息
* Location对象：表示URL的地址信息

下面我们来逐个说明这5个对象。
***

### window对象

window对象在浏览器中，是扮演着两个角色的：
* 从**EMCAScript语言**的角度来看，window对象是**全局环境的绑定对象一一也就是全局对象**。
* 从**浏览器的角度**来看，window对象是**浏览器提供的访问自身的一个接口**一一外界通过操作这个接口来操作浏览器。

#### 作为全局对象的window对象

作为全局对象的window,会将全局作用域中声明的变量，函数作为全局对象的属性。

而全局作用域中的变量 和 全局对象中的属性 ，还是有些许不同的。

其主要不同主要集中在一点：**属性的描述符对象**：
* 通过声明产生的变量，其在全局对象上的属性描述符的configurable特性为false
* 普通的为全局对象添加属性，默认的属性描述符的configurable特性为true。
* 例外的是，在eval语句中声明的变量，属性描述符的configurable特性为true。 

而由此带来的就是 全局对象的属性和全局变量在面对delete操作符具有不同的反应：**全局变量不可删除，而全局对象的属性可以删除**。

还有一点区别，访问全局变量和访问全局对象的属性是方式是不同的:
* 使用普通的属性名或者变量名进行访问属性或者变量时,进行的是**标识符解析**一一根据词法环境获取标识符绑定的值。
* 使用 window.属性名或者window.变量名进行访问属性或变量时,进行的第一步也是标识符解析，不过解析的是window, 随后，进行的是**属性获取**操作。

表现出来的影响就是：**如果通过普通的属性名访问一个不存在的属性，那么会抛出异常，而通过window.属性名访问一个不存在的属性，那么只会返回undefined。**

#### 作为浏览器窗口的实例的window对象

作为浏览器窗口的实例的window对象会被当做是当前窗口的实例对象,用于操作当前窗口。

此时，不同窗口中的window对象并不是同一个对象。

##### 窗口框架

在一个窗口中，可以包含多个其他窗口，也就是形成窗口框架。

窗口框架使用如下格式声明:

     <frame src="作为窗口框架一员的位置" name="该框架窗口的名字">

而窗口框架的布局使用如下格式：

    <frameset cols="" rows="" >
               ...
               中间声明窗口框架成员
               <frame ...>
               <frame ...>
               ...
    </frameset> 
    
需要注意的是，如果代码中**使用了这种窗口框架frame，那么代码中不能出现body标签**。 这两个标签是互斥的，不能兼容的。

窗口对象window的name属性代表该窗口的名字。 默认情况下，**window的name属性为空字符串并且不能被修改**一一除非该窗口是被其他窗口打开的并进行命名或者是作为框架窗口被指定了名称。

在框架窗口中,window的:
* frames属性: 指向该窗口中**包含的直接窗口的类数组对象**。
* top属性: 指向该窗口的最顶层窗口，也就是**浏览器窗口**,我们可以理解为浏览器的标签页所代表的窗口。
* parent属性： 指向该窗口的父框架窗口，也就是**直接包含该窗口的窗口**。 如果没有，则指向自身。
* self属性： 指向该窗口本身，对于任何窗口：**self==this==window**。

窗口框架中，父窗口也无法直接访问子窗口中window上的属性，必须通过子窗口的window属性才可访问。

##### 窗口间的属性访问以及函数调用

不同窗口间的属性访问，可以通过获取各自窗口的window对象来进行。 当然前提是通过了 跨域策略。

这里有一个需要注意的地方，窗口间的函数互相调用问题,这里的函数互相调用分为两种情况: 假设存在窗口 a 和 窗口 b ，b中window上拥有foo函数。
* 在窗口a中，**控制窗口b调用函数**foo。 一一 此时，函数的实际的执行环境在窗口b中，等效于在窗口b的控制台中 输入 foo()
* 在窗口a中，**调用窗口b中的函数**foo。 一一 此时，函数的实际的执行环境在窗口a中，而不是在窗口b中！

这两种调用方式是不同的，本质上，区别这两种调用方式的是 调用时的对象取值一一 aWindow.foo 或者是 fWindow.foo.

同时我们需要注意一个小细节，不同窗口间的函数调用，必须显式的指明 调用者对象，这是一个好习惯，否则可能会出现意想不到的情况。

具体参看 窗口间的属性访问和函数调用 的例子。


##### 窗口位置和窗口大小

window对象具有以下**获取位置**相关的属性:
* screenLeft 或 screenX 表示窗口相对屏幕左边的位置
* screenTop 或 screenY 表示窗口相对屏幕上边的位置

需要注意的是，位置属性返回的永远是**最顶层的top窗口的位置**，也就是说 窗口框架下所有的窗口的该属性都是与top保持一致的。

window对象具有以下**移动位置**相关的方法:
* moveTo(x,y)  窗口左上角移动到(x,y)位置。
* moveBy(x,y)  窗口根据x和y按照当前位置做相对移动。

这两个移动窗口位置的方法，大多数情况是禁用的，当且仅当在以下条件同时满足时，才会生效：
* 被移动的窗口是**通过window.open 函数打开**的。
* 被移动的窗口**必须仅有一个标签页**，也就是说是独立的窗口。

需要注意的是，这两个移动位置的方法同样只能对最顶层top窗口使用，而对 窗口框架内部使用则是无效的。


window对象中对窗口大小信息的描述往往在不同版本的不同浏览器中有较大区别。其主要原因在于浏览器对 innerHeight,outerHeight等属性返回的区域部分不同。

一般而言 outer相关的，返回的是整个浏览器页面的大小，而inner相关的则是返回网页视图区的大小。 

总而言之，要想获取浏览器的可视区域大小可以通过下面代码获取:

    var width = window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth;
    var height= window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight;
                    
而改变窗口大小的方法有：
* resizeTo(x,y)
* resizeBy(x,y)

和移动窗口的方法一样，只能对顶层top窗口使用，并且跟移动窗口位置的限制相同：
* 被改变大小的窗口必须是**通过window.open 函数打开**的。
* 被改变大小的窗口必须仅有一个标签页，也就是说是独立的窗口。

##### 打开窗口

window.open()方法提供了打开一个特定URL的窗口的功能。 该方法具有三个参数：
* 要加载的URL地址
* 窗口目标，如果不填等同于填入"_blank" 。此外:
 
    * 填入"_self"表示在本窗口打开
    * 填入"_top"表示在顶层窗口打开
    * 填入"_parent"表示在父层窗口打开
    * 填入"_blank"表示在新的窗口打开
    * 填入 窗口名 字符串，表示在name属性为该窗口名的窗口打开。如果该name属性的窗口已经存在，那么在那个已经存在的窗口中打开，否则在一个新的窗口打开，并且该窗口的name属性为窗口名。

* 新窗口的特性字符串。 在窗口目标被填入并且是打开新的窗口的情况下，该特性字符串描述了新的窗口的特性。常用特性有 height,width,left,top.

>> 需要注意的是，新窗口的特性字符串是以下形式 :  "width=100,height=100,left=200,top=200".  而不是CSS里的 "width:100px;height:100px;left:200px;top:200px".

该方法会返回打开的窗口的window对象，我们可以通过操作该window对象来控制打开的窗口的行为，比如修改位置moveTo,修改大小resizeTo。

原始窗口和新窗口间的通信目前来看，**除非关闭页面，否则无法真正切断联系**，就算在新窗口中设置 opener=null后，只要保存着原始窗口的window引用，新窗口依旧可以恢复同原始窗口的通信,而原始窗口始终都保持着对新窗口的控制。
具体可以参看 原始窗口和新窗口的联系.html   

总的来说，关于这些浏览器多窗口操作行为的，ES5规范中并没有给出明确的说明。因此很多都可以说是浏览器的自定义行为，不同浏览器中的行为差异是存在的。 这里主要是使用谷歌浏览器进行测试的。


##### 间歇调用和超时调用 (定时器)

间歇调用setInterval和超时调用setTimeout是window对象提供两个定时器方法。 该方法接受以下参数:
* 函数对象 或者 函数体代码字符串
* 间隔时间或超时时间 ， 这是可选参数，如果不设置，则默认为0
* 调用定时器中回调函数的 参数列表。 

需要指出的是,无论在严格或者非严格模式下，定时器的内部回调方法的**this取值永远指向全局对象**(bind方法绑定了this的函数对象除外)。 因为，定时器方法的代码均是在全局作用域下执行。

同时还需要注意的是,定时器是具有最小间隔时间的，也就是说无法立即执行,一般而言，浏览器中的定时器方法的**实际最小间隔时间为4ms**，就算设置间隔时间为0，也会这样。

定时器的原理是在ECMAScript中具有一个任务队列，定时器方法的回调方法都排在这个队列中，并选择在合适的时间依次执行。

而ECMAScript是**单线程的语言**，因此，必须等待代码段全部执行完毕后，才会开始执行任务队列中的回调函数的代码。 

##### 实现0ms延时的定时器

window.postMessage方法是浏览器实现安全的跨域通信的方法. 在这里我们却可以使用postMessage这个方法来模拟 0 ms的定时器。

原理: 在本窗口中发送一个 Message消息，再在本窗口上创建一个监听器用于监听MessageEvent,并用对应的处理方法来进行处理。

本质上利用的是事件监听机制。

同样需要注意的是，这种定时器也是必须在代码全部执行完毕后才会开始执行回调函数，和普通的定时器没有本质区别。

##### 系统对话框

系统对话框是浏览器提供给我们使用的一系列默认的对话框。 具有以下特点:
* 其样式无法更改，由操作系统及浏览器设置决定
* **模态**一一也就是说当使用了系统对话框后必须关闭该对话框后才能继续操作页面
* **同步**一一也就是说显示这些对话框时，代码会停止执行，直到关闭对话后才会恢复执行

具体有以下方法:
* alert(提示字符串)              用于为用户展示提示信息。 **返回值永远为undefined**
* confirm(提示字符串)            用于让用户确认或者取消。 如果用户点击确认返回true，否则返回false
* prompt(提示字符串，默认输入)     用于让用户输入信息。 如果用户**取消输入，那么返回null**。 否则返回输入的字符串

***

### Location对象

Location对象是BOM中非常重要的一个对象，他提供获取当前加载的文档的信息，更确切的说是跟URI有关的信息。

同时Location对象也是一个比较特别的对象，既是window对象的属性，也是document对象的属性。 也就是说 window.location === document.location

以下是location对象的重要属性:
* host 返回服务器的名称和端口号(如果有的话)的字符串
* hostname 返回服务器的名称
* port 返回服务器的端口号
* protocol 返回协议名称
* pathname 返回资源路径
* href 返回完整URL(浏览器地址栏显示的)。
* search 返回URL的参数字符串,也就是URL中 ? 后面的字符串。 如果有参数字符串，那么返回的字符串以 ? 开头
* hash 返回 URL地址中的hash值，也就是 URL中 # 后面的字符串。如果没有hash，那么返回空字符串。

下面举例说明:

    对于 https://github.com/Reveur000?param=321#hashvalue 这个URL来说
    
    location.hash = #hashvalue
    location.protocol = https:
    location.host = github.com
    location.hostname = github.com
    location.port = 
    location.href = https://github.com/Reveur000?param=321#hashvalue
    location.toString() = https://github.com/Reveur000?param=321#hashvalue
    location.pathname = /Reveur000
    location.search = ?param=321
    
    
需要注意的一点是， hash值**必须放在URL的最后,甚至是在参数字符串的后面**。

location对象的重要方法:
* assign(新的url) 跳转到该新的url(会留下历史记录).
* replace(新的url) 替换当前url为新的url并跳转(不会留下历史记录)
* reload(是否从服务器重新加载) 重新刷新当前页面，如果不传递参数那么可能使用缓存进行加载。
* toString() 返回完整URL。等同于href属性.

如果想要更改URL并重新加载页面，那么我们可以直接改动 location对象的 host pathname 等涉及URL的属性 进行跳转，这样同样会跳转到新的url并留下历史记录。  

需要注意的是，单独更改hash值是不会重新加载页面的,但是会留下历史记录的。 

***

### Navigator对象

navigator对象是BOM中用于表示客户端浏览器信息的对象。 

该对象的大量属性是用于标识浏览器客户端的信息，这些信息具体在 后面的 用户代理检测中讲。

这里仅仅说一下浏览器的插件检测。

navigator.plugins 返回的是一个**浏览器插件集合的类数组对象**。

浏览器的插件对象的隐式原型是Plugin.prototype 因此继承了该原型的以下属性:
* name 插件名称
* description 插件描述
* filename 插件的文件名
* length 该插件所能处理的MIME类型数量

同时 plugins 类数组对象还有一个 refresh() 方法用于刷新插件集合，如果传入true参数，那么还会刷新包含插件的所有页面。

这里我们需要注意的是，IE浏览器不支持这种方式的插件检测，因为IE浏览器的插件是以COM对象实现的。因此我们应当使用下面方法来进行检测

    function hasIEPlugin(COMID){
        try{
            new ActiveXObject(COMID); //尝试创建该插件的实例。 如果创建成功那么就存在该插件。 
            return true;
        }catch (e){
            return false;   //否则抛出异常，说明不存在该插件
        }
    }
    
需要注意的是,IE中的插件标识是使用其独有的COM对象标识符而不是插件名。 比如 flash插件的COM标识符是 ShockwaveFlash.ShockwaveFlash.


*** 

### Screen对象

Screen对象主要用来表明客户端的屏幕相关信息。 但是作用并不大。 主要有以下属性

* availWidth 当前屏幕的宽度(分辨率)
* availHeight 当前屏幕的高度(分辨率)
* pixelDepth 当前的屏幕色彩深度(存储一像素颜色所用的位数)

总体来说没多大用。

***

### History对象

History对象保存着历史浏览记录。 每个打开的窗口均**有单独的history对象**，甚至框架里的窗口window的history对象也是独立的。

需要注意的是，尽管我们可以访问history对象,但是出于安全考虑,我们却**无法获取用户的具体浏览历史记录**。

但是我们依旧可以通过以下方法控制页面在历史记录中跳转:
* go(数字) 根据历史记录向前或者向后跳转。 参数只能为数字，否则无效。 数字超过界限，也会无效。
* back() 向后跳转 等价于 go(-1)
* forward() 向前跳转 等价于 go(1)

history的length属性表示历史记录的总数，刚刚打开的新窗口的history.length值为1.据此我们可以判断是否该页面为用户第一次打开的页面。

还有一点需要注意，如果**在回退后重新跳转到新的URL，那么history.length会重新计算**.

举个例子，如果现在有5条历史记录，当我们回退到第3条的页面后，再跳转到新的页面，那么history.length此时会变为4条,而原本的第4 第5条历史记录就会丢失。