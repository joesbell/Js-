# 面对对象的程序设计

### 理解对象

ECMAScript中的对象是 无序属性的集合,其属性值可以包含基本值，函数，或者对象。
因此可以说ECMAScript的对象本身就是一个散列表,属性名是key,而属性值是value。
每一个对象都是基于一个引用类型创建的。

创建一个对象的方式有两种:
* 使用构造函数(可以创建任意引用类型的对象)
* 使用对象字面量(只能创建Object引用类型的对象)

对象的属性有两种类型：

* 数据类型

* 访问器类型

顾名思义, 数据类型的属性就是指**对象的这个属性本身就存储了一个真实存在的数据**的.

而访问器类型的属性则是 在**访问对象的这个属性时,动态地返回一个值**，这个值可能是别的数据类型的属性的属性值。
因此我们可以说，访问器类型的属性**本身是没有存储一个真实存在的属性值**。

不同类型的**属性**具有不同的**特性**。这些特性是为了实现JavaScript引擎而定义出来的,用于**描述 属性的 行为**。

比如说，数据类型的属性，本身就存储了数据，因此被读时，直接将该存储的数据返回，被写入时，直接将写入值存储进该数据位置。
而访问器类型的数据则具有不同的特性，其被读取时，按照其设定的方式 返回一个值，被写入时，按照其设定的方式 对写入值 进行操作。

下面再细说.

##### 数据类型的属性

数据类型的属性本身包含一个数据值。 其一共具有4个特性:

共同特性:

* \[\[Configurable]] 本身是boolean值，表示能否删除该属性，能否重新配置该属性，能否修改该属性的特性，能否把属性类型修改为访问器属性。

* \[\[Enumerable]] 本身是boolean值,表示能否通过 for-in 语句遍历返回该属性。

私有特性:

* \[\[Writable]] 本身是boolean值,表示能否修改属性的值

以上三个特性在对对象直接添加属性时,自动配置为true.

* \[\[Value]] 存储该属性的值. 读取该属性时，从这个位置读取，写入该属性时，对该位置写入。 默认值 undefined.

我们可以通过 Object引用类型的静态方法defineProperty(对象实例,属性名,描述特性的对象)来定义属性。

关于修改 数据类型的属性的值的方式有两种:
* 重定义特性中的value,这是由 configurable特性掌管的。
* 直接对属性进行赋值,这是由 writable特性掌管的。

因此,只有当属性的writable和configurable特性均为false时，其value才是真正地无法更改的。

所有特性中，只有configurable特性是设置为false后就不能重新定义更改的，重定义会报错，其他的特性都可以在configurable为true的情况下重定义。

普通的为对象添加属性,也就是**定义 数据类型属性，其特性默认都是true,而在定义属性的特性过程中，如果不显式地指定特性为true,那么默认是为false的。**
而value值,只要不赋值都是undefined.

**普通的为对象添加的属性均是 数据类型 属性**。

##### 访问器类型的属性

访问器类型的属性本身是不包含数据值的。 其一共具有4个特性:

共同特性:

* \[\[Configurable]] 本身是boolean值，表示能否删除该属性，能否重新配置该属性，能否修改该属性的特性，能否把属性类型修改为数据属性。

* \[\[Enumerable]] 本身是boolean值,表示能否通过 for-in 语句遍历返回该属性。

私有特性:

* \[\[Get]] 在**读取**该访问器属性时调用的函数。 默认为undefined.

* \[\[Set]] 在**设置**该访问器属性时调用的函数。 默认为undefined.

需要注意的是,**访问器类型的属性只能通过定义属性的方式定义**，而不能使用普通的添加属性的方式定义。

同样的，在定义访问器类型的属性的特性过程中**不显式指明特性的值，其公有特性默认赋值false，其私有特性默认赋值undefined**。

在不支持Object的静态方法defineProperty的浏览器中，可以使用 非标准方法 __defineGetter__(属性名，函数)
和__defineSetter__(属性名，函数) 来定义访问器属性，但是需要注意的是，Configurable和Enumerable特性在这种情况下是无法更改的。

这里还要说明一点，同一个属性，要么是数据类型的，要么是访问器类型的，除了共同特性可以存在外，要么就存在数据的私有特性，要么就存在访问器的私有特性，
同一个属性的特性中，访问器私有特性和数据私有特性是不能同时定义共存的，会导致报错！

最后再说一个同时定义对象的多个属性的特性的方法一一Object.defineProperties()方法可以同时定义对象的多个属性的特性。

    var person={};
    Object.defineProperties(person, {
                //定义两个访问器类型属性
                name: {
                    configurable: true,
                    value: "Reveur",
                    writable: false,
                    Enumerable: true
                },
                age: {
                    configurable: true,
                    value: 23,
                    writable: true,
                    Enumerable: true
                },
                //定义一个访问器类型属性
                _info: {
                    configurable: true,
                    Enumerable: true,

                    //特别注意！set和get方法中，如果要访问对象自身的属性，必须加上this.属性名

                    set: function (newAge) {
                        console.log("修改了年龄");
                        this.age = newAge;
                    },
                    get: function () {
                        return "姓名:" + this.name + ",年龄" + this.age;
                    }
                }
            }
        );


既然能手动设置属性的特性值，那么我们也可以读取属性的特性值，其方法是 Object.getOwnPropertyDescriptor(对象,属性名),该方法返回一个对象。

如果是 数据类型的属性,那么我们获取该对象的configurable,enumerable,writable,value属性的属性值是有意义的。

如果是 访问器类型的属性,那么我们获取该对象的configurable,enumerable,set,get属性的属性值是有意义的。

这里所谓的有意义指的是，我们能基本确定 其值不会是undefined。 因为 对一个在对象上不存在的属性进行访问也会获取一个值:undefined,这就是无意义的。

***

### 创建对象(创建一个引用类型)

需要首先说明的是，这里说创建对象主要是针对创建引用类型的对象，而不是单纯创建一个Object类型的对象。

##### 普通的创建对象

关于创建对象，有很多值得说道的地方，首先创建Object对象的方式有两种，利用Object构造函数和使用对象字面量。

当Object对象创建成功后，我们只需要在该对象上增加属性就能获得我们想要的对象了。这显然是一种创建某种引用类型对象的方式。

**缺点**在于:
* **1.缺乏代码的复用**，每创建一次该引用类型的对象，就需要再次书写代码，没有封装性。
* **2.无法识别对象的真正的引用类型**,因为所有通过这种方式创建出来的对象都只会属于Object引用类型。

##### 工厂模式

**动机**:工厂模式是为了解决普通的创建对象的方式的第一个缺点一一缺乏代码复用而产生的。

**核心思路**:把原本创建相同类型的对象的过程集中在一个函数中进行，我们每次只需要调用该函数就可以创建一个新的对象。
并且还可以通过参数的不同，调整创建出的对象的属性。

**缺点**:**依旧无法解决 对象的类型识别问题**。

##### 构造函数模式

**动机**:构造函数模式是为了解决 工厂模式的 对象类型识别问题而产生的.

**核心思路**: 利用 函数创建对象时会自动将该对象的隐式原型指向函数的原型，而一旦指向了函数的原型，
那么  该对象 instanceof 该函数 就会返回true。由此就可以成功地完成对象的类型识别问题。
而构造函数的函数体只需要模仿工厂模式的过程即可，不同之处是不需要在函数体内部显式创建对象，而是在调用
构造函数时使用 new 操作符，在函数体内部使用 this 来访问我们将要创建出的对象。

**缺点**:**属性过度实例化**，导致本应该复用的方法也被每个对象各自创建了一份。当然这个缺点本身也是可以解决的，
只需要将当作属性的函数在外部声明，在创建对象并为属性赋值function时，将这个外部函数作为值，这样就能保证所有对象的该方法都复用
这个外部方法，但是，这样显然是不够优雅的 一一 封装性不够强。

##### 原型模式

**动机**:原型模式是为了解决构造函数模式的 属性过度实例化而产生的.

**核心思路**:每当创建一个函数时，就会**自动为该函数创建一个prototype属性**，并将该属性指向该函数的原型对象。
函数的**原型对象在默认的情况下,只会拥有一个属性constructor指向该函数本身**。
而该函数创建出的**对象实例默认将包含一个指针指向该函数的原型对象**，这个指针也叫做隐式原型。
通过这个隐式原型，对象实例才能追寻原型链找到其原型并访问原型上的属性。这也是ECMAScript中继承的原理。

因此我们就可以直接将属性和方法都放在原型上，这样所有的属性和方法就能被所有实例访问到并且只在原型对象中存储的有一份，从而可以解决属性过度实例化的问题。

**缺点**:**属性过度共享化**，这对于对象实例修改其属性是没有影响的，因为实例虽然可以访问到原型中的值，但是却不能重写原型中的值。因为默认地，都是优先
操作对象实例自身拥有的属性。如果我们对实例的属性进行重新赋值，是永远不会影响到原型的属性的。这看似是没有任何问题,或者说属性的属性值是基本类型时还没有什么问题，
但是如果是引用类型,我们却能**通过该引用类型对象的方法修改该引用类型对象自身的属性**,甚至是**可以直接为该引用类型对象添加属性**，从而导致原型对象中 引用类型对象 的属性值 对象本身发生改变。(虽然无法替换该引用类型对象)
这样就会引起所有实例访问该属性时，均受到影响。

在原型模式中还会涉及到原型属性和实例属性以及原型相关的问题:

* 判断**属性是实例的还是原型的**方法 hasOwnProperty(继承自Object):
使用方式  **实例.hasOwnProperty(属性名)**,如果是实例属性则返回true，否则返回false。

* 获取**实例的隐式原型**的方法 getPrototypeOf:
使用方式 **Object.getPrototypeOf(实例)**, 返回该实例的隐式原型对象。

* 判断**一个对象是否是另一个对象的隐式原型**的方法 isPrototypeOf:
使用方式 **实例A.isPrototypeOf(实例B)**, 返回 实例A是否是实例B的隐式原型。

* 操作符 in :
    * 使用方式1  **属性名 in 实例**  如果实例**能访问到该属性**则返回true
    * 使用方式2  **for 变量名 in 实例** 用于迭代实例**能访问到的可枚举属性**

* 获取实例所有 **可枚举的实例属性名** 的方法 keys:
使用方式 **Object.keys(实例)**  返回一个属性名数组

* 获取实例所有 **实例属性名(无论能否枚举)** 的方法 getOwnPropertyName:
使用方式 **Object.getOwnPropertyName(实例)** 返回一个属性名数组.



##### 组合使用 构造函数模式和原型模式(下面简称组合模式)

**动机**:可以说原型模式在解决属性过度实例化的问题后，又引入了一个新的问题，并且这个问题是上一个问题的相反面，这是两个极端,
因此 组合模式 就是为了解决 原型模式矫枉过正的缺陷而产生的。

**核心思路**:我们首先要明确一点,原型模式最初是为了解决什么问题而使用的，答案是:属性过度实例化，更准确的说，是为了解决
构造函数模式中 对象实例中作为属性值的函数 在每一个实例上都创建了一份 的问题。 普通属性实例化是没有问题的，有问题的只是连方法都实例化了(这里的实例化是指在每个实例都存储了单独的一份)。
那为何不对症下药呢?
因此，**普通属性是应当被实例化的，放在构造函数中;而方法是不应该被实例化的，放在原型中**。 这样就完美地解决了 过度实例化和过度共享化的问题。

**缺点**:组合模式是创建自定义类型的对象的标准模式。基本上可以说是没有缺点，硬要说缺点，那么还是有的，常规的组合模式中，构造函数的创建和对函数原型对象的修改是分开的，**显得不够具有封装型**。

##### 动态原型模式

**动机**:解决 组合模式的封装性问题.(尽管这也不是什么问题)

**核心思路**:将对 构造函数原型对象的修改 放进 构造函数中，并通过条件判断，决定是否执行 对函数原型对象的修改。

**缺点**:无


##### 寄生构造函数模式(稳妥工厂模式更为确切)

**动机**:有些**涉及到语言底层功能**的引用类型是无法通过普通的方式创建的,比如我们想要自己创建一个具有特殊功能的数组的引用类型。
我们是**无法在高层实现 检测 是否添加了数组元素的 功能**的。

**核心思路**:在构造函数内部，利用已有的构造函数创建对象，并增强这个对象，再返回这个对象。
这样对外部来说似乎就跟我们真的从头到尾实现了这个新的引用类型的构造函数一样。
本质是直接套用了工厂模式。

**缺陷**:**无法解决对象类型识别问题**

##### 稳妥构造函数模式

**动机**:ECMAScript的对象的属性默认是没有 访问权限控制的，因此可能会造成不安全的情况。
因此就需要一种**没有公开属性，其方法也不使用this**的对象一一稳妥对象来实现属性的访问控制。

**核心思路**:利用工厂模式封装过程，在工厂方法函数体中，创建局部变量模拟私有方法和私有函数，
并在工厂方法返回的对象上添加属性，属性中可以使用这些私有方法和私有函数。

**缺陷**:**依旧是对象类型识别问题**

***

### 继承

在传统的OO语言中，一般都支持两种继承方式:
* 接口继承：只继承方法的签名，子类需要自己实现方法。
* 实现继承：直接继承父类实现的方法，但是子类可以重写这个方法。

由于EMCAScript中没有函数签名的概念，因此接口继承是无法实现的。ECMAScript只能使用实现继承，
并且其实现继承也与普通的OO语言不同，是依靠原型链实现的。

##### 原型链模式

**核心思路**:所谓原型链模式，就是将 **某个引用类型(父类)的实例 作为 另一个引用类型(子类)的原型对象**。

这里我们首先假设，父类的引用类型的创建对象的模式是标准组合模式：实例的属性在实例上，而复用的方法在其构造函数的原型对象上。

子类在创建对象时，其实例的隐式原型就指向父类的实例，因此，子类能访问父类的属性，而父类的实例肯定能访问父类的原型
对象的方法，由此，子类就能访问父类的原型对象的方法。这就是原型链模式。 当然方法也是属性，只是这些方法属性在标准组合模式下是放在
原型对象上而不是实例上。

在说缺陷之前，我们首先要明晰一点一一**原型链模式的继承 本质和 原型模式的创建对象 是一样的**。
都是依赖 **连接 构造函数，原型对象，对象实例 这三者的两个指针**：**构造函数的原型prototype**，**对象实例的隐式原型__proto__**。
凭借EMCAScript的属性访问机制一一原型链，实现的 创建一个引用类型 和 引用类型的继承。

**缺陷**:

1. 属性的共享化一一导致创建出来的对象本身没有父类的实例属性。这个缺陷继承自 原型模式。

2. 无法自由地向构造函数传参，导致了父类属性的**值的同质化**。

    这个缺陷在原型模式中就存在，不过被掩盖掉了，毕竟其核心也只是为了解决类型识别问题,并且原型模式的确给创建对象提供一个模板，这个模板规定了对象应该具有什么属性，对象的实例属性可以在创建好了之后再自行添加。

    但是在继承过程中，这个缺陷就被放大了，毕竟，我们**继承的目标是继承某个引用类型定义的属性，而不是仅仅继承某个引用类型的一个特定实例拥有的属性**。

##### 借用(父类)构造函数模式

**核心思路**:所谓借用构造函数模式，实际上就是将原本的父类创建对象的函数在子类的构造函数中**普通调用**，将其**从创建父类对象变成了在子类对象上添加实例属性**。
这里往往是通过父类构造函数的apply/call方法实现在传入的参数对象this上添加实例属性的过程，同时还可以在这个过程中自由传参。这样,
子类创建出的对象本身就具备**父类在构造函数中实例化的属性**了。此外，再在构造函数中对创建出的子类对象进行增强，赋予其子类所需实例化的属性。

**缺陷**:

1. 访问不到父类原型对象上的属性(往往这些属性是公有方法),因此会造成继承的不完全。而如果对 父类的所有属性都进行实例化，那么显然，函数对象的复用
得不到实现，因此，这个缺陷是避不开的。

2. 无法正确地进行类型识别，**子类对象只能识别其子类，而不能识别其父类**，因为没有对原型链进行操作。

归根结底，都是出在没有对原型链进行操作上。 因此，参考 组合模式创建对象 是融合了 原型模式和构造函数模式，在实现继承的过程中，
也随之需要这种类似的组合互相搭配。

##### 组合继承

**核心思路**:组合继承的本质是 使用 借用构造函数模式来继承**父类的实例属性**，再使用原型链模式来继承**父类原型对象上的原型属性**。
这样，每个子类实例本身应该具有的私有属性(不管是父类规定的还是子类规定的)都得到了充分的实例化，而其应该共享的属性和方法，都通过原型链，
使得实例得以访问到原型对象上的公有属性和方法。

**缺陷**:在组合继承中，存在着重复的属性一一父类所规定的实例属性不仅仅是存在于子类实例对象中，而且还存在于子类原型对象中。
因此可以说，存在于原型对象中的父类实例属性是多余的，毕竟我们对原型对象的需求并不是其上的实例属性，而是公有属性。
但是，这个缺陷也可以说是小到微乎不计。因此，组合继承成为了ECMAScript中最常用的继承方式。

***

上面所有的继承方式都是**继承一个引用类型**。

然而，有时候我们并不需要继承一个引用类型，而仅仅是只需要继承一个对象罢了。
虽然这个说法听起来很奇怪，毕竟OO中常规的继承都是说的是继承一个类型，但是这在ECMAScript中却不是很奇怪的一件事，
之前就说过，ECMAScript本身是一个很自由的语言，从其继承就可以看出来，**整个继承过程更象是将一个对象的属性修整成某种引用类型的样子**，
而其类型识别，也是根据原型链，将子类实例的原型链修正成既经过子类原型对象，又经过父类原型对象。

因此我们可以总结一下， ECMAScript的继承一个引用类型，本质是
**通过 构造函数 修整属性 完成属性的继承**，
**通过 原型 修正原型链 完成 类型的识别**，当然，顺带着，**公有属性的访问也得到了实现**。

当我们只需要简单的继承一个对象时，上面的方法就显得臃肿了.

举个例子，有一个对象，叫做 Human，其具有一个属性 MotherPlanet,其值为 Earth.
很显然地，所有的人都应该继承了这个对象，更为精准的说法是，所有的人都应该**继承这个对象的属性**。
此时,如果我们再使用以上的方式来实现这种继承就真的显得臃肿了。

所以就有了下面的特殊继承模式，专门用于继承某个对象而不是某个引用类型。

##### 原型式继承

**核心思路**：所谓原型式继承，本质就是 将 **待继承的对象作为原型对象来使用**。这样，继承该对象的实例通过隐式原型就能在原型链上
找到这个待继承的对象，由此，获取待继承对象的属性的访问权。

我们这里对比一下几种 纯 原型 模式的形式：
* 创建许多类似对象(或者说创建一种引用类型的方式)的 原型模式：将所有属性都放在 构造函数的原型对象上。 结果:所有的实例都可以访问到这个原型对象上的属性。
* 继承一个引用类型的 原型链模式：将子类原型对象设置为 父类实例。 结果:所有的子类实例都能访问到 父类实例的所有实例属性。 再通过父类实例，又能访问到父类原型对象的所有属性。
* 继承一个对象的 原型式继承模式：将实例的隐式原型设置为 该对象。 结果:所有实例都能访问到 该对象上的所有属性。 再通过该对象的隐式原型对象，又能访问到其原型链上的所有属性。

抽象一下，为什么实例能访问到原型对象上的属性? 答案:因为**实例具有一个指针，指向了另一个对象。这个指针就叫做隐式原型**。
而另一个对象可以是什么呢？函数的原型对象只是其中的一种情况，本质是**任何一个对象都可以当实例的隐式原型对象**。

因此，如果我们想要实例继承另一个对象应该怎么做？ 答案: **将实例的隐式原型指向另一个对象即可**。
当然，我们这里说的继承，只是单单的说的是一种**属性的访问**，而**不是真正的将属性实例化**。

看破了这一点，那么我们就能很好的理解 原型式继承 的原理了。


    function object(o){
        function F(){
        }
        F.prototype=o;
        return new F();
    }

以上便是原型式继承的完整代码，用于创建一个继承自对象o的实例。Object引用类型提供了一个标准方法 Object.create(o)来创建一个继承o对象的实例。

之前我们就说过 **构造函数 原型对象 对象实例** 之间的联系:

1. **构造函数** 的 **prototype原型属性** 指向 **原型对象**;

2. **构造函数** 创建出的 **对象实例** 的 **__proto__隐式原型属性** 也指向 **原型对象**。

此时回过头来看原型式继承,一目了然,本质就是 **创建一个空对象，其隐式原型是指向待继承对象**。

    function object(o){
        var temp={};
        temp.__proto__=o;
        return temp;
    }

以上代码完全等价.

##### 寄生式继承

记住一个式子即可:  **寄生式继承 = 原型式继承 + 增强返回对象**

模式与 工厂模式和寄生构造函数模式极其相似，都是 创建一个对象，并对该对象进行增强后 再返回。
缺陷也相同:实例属性中的函数没有复用。


之所以说这两个模式是为了下面作铺垫。总之我们只要牢记一点： **实例的隐式原型指向谁，就能访问谁的属性**。

***

##### 寄生组合继承一一对组合继承的改进

组合继承中，子类的原型对象上的父类实例属性是多余的，我们仅仅只是需要父类的原型对象的属性的访问权罢了。

此时回过头来看看其子类实例原型链:

      子类实例 ------------> 子类原型对象 == 父类实例 ------------> 父类原型对象
              通过隐式原型              等于         通过隐式原型

我们的 子类原型对象 为什么 一定要借助 父类实例 去指向 父类原型对象呢？
直接将 子类原型对象 通过隐式原型 指向 父类原型对象 不就好了吗？
毕竟我们的目标**只是想要获取父类原型对象的属性的访问权**罢了。

化简后的原型链:

      子类实例 ------------> 子类原型对象 ------------> 父类原型对象
              通过隐式原型                通过隐式原型

而这，就是寄生组合继承。

寄生组合继承可以说是一种最完美的 继承引用类型的方式了。
**实例属性通过构造函数完全实例化，共享属性通过原型链完全共享化。**
比之组合继承更加难能可贵的是，所有的对象均**没有任何存储上的冗余**：

|名称   |    存储分数   | 存储位置|
|------|-------------|--------|
|公有的属性|   1份    |原型对象上|
|实例的属性|   1份    |每个实例上|